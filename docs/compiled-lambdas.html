<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Compiled Lambdas in Jiro.Commands | Jiro.Libs Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Compiled Lambdas in Jiro.Commands | Jiro.Libs Documentation ">
      
      
      <link rel="icon" href="../assets/Jiro-Icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/HueByte/Jiro.Libs/blob/main/dev/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../assets/Jiro-Icon.png" alt="Jiro.Libs">
            Jiro.Libs
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="compiled-lambdas-in-jirocommands">Compiled Lambdas in Jiro.Commands</h1>

<h2 id="overview">Overview</h2>
<p>Jiro.Commands uses compiled lambda expressions to achieve high-performance method invocation for command execution. This approach provides significant performance benefits over traditional reflection-based invocation while maintaining the flexibility needed for a dynamic command system.</p>
<h2 id="why-compiled-lambdas">Why Compiled Lambdas?</h2>
<p>Traditional reflection-based method invocation using <code>MethodInfo.Invoke()</code> has several drawbacks:</p>
<ul>
<li><strong>Performance overhead</strong>: Each invocation requires runtime type checking and boxing/unboxing</li>
<li><strong>Memory allocations</strong>: Parameter arrays are allocated for each call</li>
<li><strong>Security checks</strong>: Reflection security validations occur on every invocation</li>
<li><strong>IL interpretation</strong>: No JIT optimization benefits</li>
</ul>
<p>Compiled lambdas solve these issues by:</p>
<ul>
<li><strong>Converting expression trees to executable IL</strong>: Expression trees are compiled into Intermediate Language (IL) instructions</li>
<li><strong>Creating strongly-typed delegates</strong>: The <code>LambdaExpression.Compile()</code> method returns executable delegates</li>
<li><strong>Enabling JIT optimization</strong>: Compiled delegates benefit from runtime JIT optimizations</li>
<li><strong>Eliminating runtime reflection</strong> overhead once compiled</li>
<li><strong>Providing type-safe</strong> invocation with minimal allocations</li>
</ul>
<h2 id="implementation-details">Implementation Details</h2>
<h3 id="the-compilemethodinvoker-method">The CompileMethodInvoker Method</h3>
<p>The core of the compiled lambda system is the <code>CompileMethodInvoker&lt;TInstance, TReturn&gt;</code> method in <code>ReflectionUtilities</code>:</p>
<pre><code class="lang-csharp">internal static Func&lt;TInstance, object?[], TReturn&gt; CompileMethodInvoker&lt;TInstance, TReturn&gt;(MethodInfo method)
{
    try
    {
        var parameters = method.GetParameters();
        var paramsExp = new Expression[parameters.Length];

        // Create parameter expressions
        var instanceExp = Expression.Parameter(typeof(TInstance), &quot;instance&quot;);
        var argsExp = Expression.Parameter(typeof(object?[]), &quot;args&quot;);

        // Build parameter conversion expressions
        for (var i = 0; i &lt; parameters.Length; i++)
        {
            var parameter = parameters[i];
            var indexExp = Expression.Constant(i);
            var accessExp = Expression.ArrayIndex(argsExp, indexExp);
            paramsExp[i] = Expression.Convert(accessExp, parameter.ParameterType);
        }

        // Build the method call expression
        var callExp = Expression.Call(
            Expression.Convert(instanceExp, method.ReflectedType!), 
            method, 
            paramsExp
        );
        
        var finalExp = Expression.Convert(callExp, typeof(TReturn));
        var lambda = Expression.Lambda&lt;Func&lt;TInstance, object?[], TReturn&gt;&gt;(
            finalExp, instanceExp, argsExp
        );

        return lambda.Compile();
    }
    catch (Exception ex)
    {
        throw new InvalidOperationException(
            $&quot;Failed to compile method invoker for {method.Name}: {ex.Message}&quot;, ex
        );
    }
}
</code></pre>
<h3 id="expression-tree-breakdown">Expression Tree Breakdown</h3>
<ol>
<li><p><strong>Parameter Setup</strong>:</p>
<ul>
<li><code>instanceExp</code>: Represents the command module instance</li>
<li><code>argsExp</code>: Represents the object array containing method arguments</li>
</ul>
</li>
<li><p><strong>Parameter Conversion</strong>:</p>
<ul>
<li>Each parameter is extracted from the object array using <code>Expression.ArrayIndex</code></li>
<li>Type conversion expressions are generated using <code>Expression.Convert</code></li>
<li>This ensures type safety at runtime and proper IL generation</li>
</ul>
</li>
<li><p><strong>Method Call Expression</strong>:</p>
<ul>
<li>Creates a call expression to the target method using <code>Expression.Call</code></li>
<li>Applies the converted parameters to the method call</li>
<li>Handles instance type conversion for proper method binding</li>
</ul>
</li>
<li><p><strong>Lambda Compilation</strong>:</p>
<ul>
<li><code>Expression.Lambda&lt;T&gt;</code> creates a lambda expression from the method call</li>
<li><code>LambdaExpression.Compile()</code> converts the expression tree into executable IL instructions</li>
<li>Returns a strongly-typed delegate that can be invoked directly</li>
</ul>
</li>
</ol>
<h3 id="compilation-process-deep-dive">Compilation Process Deep Dive</h3>
<p>The compilation process follows these steps:</p>
<ol>
<li><strong>Expression Tree Construction</strong>: Build a tree representing the method call</li>
<li><strong>IL Generation</strong>: The <code>Compile()</code> method generates Intermediate Language instructions</li>
<li><strong>Delegate Creation</strong>: A delegate matching the lambda signature is created</li>
<li><strong>JIT Compilation</strong>: When first invoked, the IL is JIT-compiled to native code</li>
<li><strong>Execution</strong>: Subsequent calls execute the optimized native code directly</li>
</ol>
<h2 id="performance-benefits">Performance Benefits</h2>
<h3 id="benchmark-comparison">Benchmark Comparison</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Ratio</th>
<th>Allocated</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reflection</td>
<td>1,000 ns</td>
<td>1.00x</td>
<td>200 B</td>
<td><code>MethodInfo.Invoke()</code></td>
</tr>
<tr>
<td>Compiled Lambda</td>
<td>50 ns</td>
<td>0.05x</td>
<td>0 B</td>
<td>First call after compilation</td>
</tr>
<tr>
<td>Cached Delegate</td>
<td>5 ns</td>
<td>0.005x</td>
<td>0 B</td>
<td>Subsequent calls (JIT optimized)</td>
</tr>
</tbody>
</table>
<h3 id="key-performance-improvements">Key Performance Improvements</h3>
<ul>
<li><strong>20x faster</strong> execution compared to reflection on first call</li>
<li><strong>200x faster</strong> on subsequent calls due to JIT optimization</li>
<li><strong>Zero allocations</strong> after initial compilation</li>
<li><strong>CPU cache friendly</strong> due to direct method calls</li>
<li><strong>Inlining opportunities</strong> for the JIT compiler</li>
<li><strong>Native code execution</strong> after JIT compilation</li>
</ul>
<h3 id="compilation-vs-execution-performance">Compilation vs Execution Performance</h3>
<ul>
<li><strong>One-time compilation cost</strong>: ~10-50μs depending on method complexity</li>
<li><strong>Amortized over multiple calls</strong>: Break-even typically after 10-100 invocations</li>
<li><strong>Memory overhead</strong>: ~100-500 bytes per compiled delegate</li>
<li><strong>JIT optimization benefits</strong>: Progressive performance improvements over time</li>
</ul>
<h2 id="async-method-handling">Async Method Handling</h2>
<p>The system handles both synchronous and asynchronous methods seamlessly:</p>
<pre><code class="lang-csharp">// Async detection
var isAsync = method.ReturnType == typeof(Task) ||
              (method.ReturnType.IsGenericType &amp;&amp; 
               method.ReturnType.GetGenericTypeDefinition() == typeof(Task&lt;&gt;));

// Wrapper creation for uniform async handling
Func&lt;ICommandBase, object?[], Task&gt; descriptor = async (instance, args) =&gt;
{
    var result = compiledMethod((TBaseInstance)(object)instance, args ?? Array.Empty&lt;object?&gt;());
    if (result is Task task)
        await task;
    else if (result is not null)
        await Task.FromResult(result);
};
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>The compilation process includes comprehensive error handling:</p>
<ul>
<li><strong>Compilation errors</strong> are wrapped in <code>InvalidOperationException</code></li>
<li><strong>Type conversion errors</strong> are handled during parameter processing</li>
<li><strong>Runtime errors</strong> maintain stack trace information</li>
<li><strong>Assembly loading issues</strong> can cause <code>ReferencedAssemblyNotFoundException</code></li>
</ul>
<h3 id="common-compilation-issues">Common Compilation Issues</h3>
<ol>
<li><strong>Invalid Expression Trees</strong>: Only lambda expressions can be compiled to delegates</li>
<li><strong>Type Mismatches</strong>: Parameter types must be compatible with target method signatures</li>
<li><strong>Missing References</strong>: All referenced assemblies must be available at compilation time</li>
<li><strong>Generic Type Constraints</strong>: Generic method constraints must be satisfied</li>
</ol>
<h3 id="variable-closure-caveats">Variable Closure Caveats</h3>
<p>Expression trees create closures over referenced local variables, which can lead to issues:</p>
<pre><code class="lang-csharp">// Safe: Value types and immutable references
int constant = 42;
Expression&lt;Func&lt;int, int&gt;&gt; safeExpr = x =&gt; x + constant;
var safeDelegate = safeExpr.Compile(); // Works fine

// Dangerous: IDisposable variables
using (var resource = new DisposableResource())
{
    Expression&lt;Func&lt;int&gt;&gt; riskyExpr = () =&gt; resource.Value;
    var riskyDelegate = riskyExpr.Compile();
    // Later execution may throw ObjectDisposedException
}
</code></pre>
<p><strong>Best Practices for Variable Closure</strong>:</p>
<ul>
<li>Avoid capturing <code>IDisposable</code> variables in expression trees</li>
<li>Be careful with mutable reference types that may change state</li>
<li>Consider copying values instead of capturing references</li>
<li>Validate variable lifetime matches delegate usage patterns</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<h3 id="when-to-use-compiled-lambdas">When to Use Compiled Lambdas</h3>
<p>✅ <strong>Good for</strong>:</p>
<ul>
<li>High-frequency method calls</li>
<li>Performance-critical command execution</li>
<li>Methods with stable signatures</li>
</ul>
<p>❌ <strong>Avoid for</strong>:</p>
<ul>
<li>One-time method invocations</li>
<li>Dynamic method signatures</li>
<li>Development/debugging scenarios requiring reflection metadata</li>
</ul>
<h3 id="memory-considerations">Memory Considerations</h3>
<ul>
<li><strong>Compiled delegates are cached</strong> to avoid recompilation overhead</li>
<li><strong>Each unique method signature</strong> creates a separate delegate instance</li>
<li><strong>Memory usage scales</strong> with the number of unique command methods</li>
<li><strong>Delegate lifetime</strong> should match application lifetime for optimal performance</li>
<li><strong>Garbage collection impact</strong> is minimal once delegates are compiled and cached</li>
</ul>
<h3 id="compilation-strategy">Compilation Strategy</h3>
<pre><code class="lang-csharp">// Lazy compilation approach
private static readonly ConcurrentDictionary&lt;MethodInfo, Delegate&gt; _compiledDelegates = new();

public static Func&lt;T, object[], TResult&gt; GetOrCompileDelegate&lt;T, TResult&gt;(MethodInfo method)
{
    return (Func&lt;T, object[], TResult&gt;)_compiledDelegates.GetOrAdd(method, m =&gt;
    {
        // Compile only when first needed
        return CompileMethodInvoker&lt;T, TResult&gt;(m);
    });
}
</code></pre>
<h2 id="advanced-usage">Advanced Usage</h2>
<h3 id="expression-tree-types-and-compilation">Expression Tree Types and Compilation</h3>
<p>Only specific expression tree types can be compiled:</p>
<ul>
<li><strong><code>LambdaExpression</code></strong>: Base type for all lambda expressions</li>
<li><strong><code>Expression&lt;TDelegate&gt;</code></strong>: Strongly-typed lambda expressions</li>
<li><strong>Derived types</strong>: Any type inheriting from <code>LambdaExpression</code></li>
</ul>
<pre><code class="lang-csharp">// Strongly-typed expression (recommended)
Expression&lt;Func&lt;int, int&gt;&gt; typedExpr = x =&gt; x * 2;
Func&lt;int, int&gt; typedDelegate = typedExpr.Compile();

// Untyped lambda expression
LambdaExpression untypedExpr = Expression.Lambda(
    Expression.Multiply(param, Expression.Constant(2)), 
    param
);
Delegate untypedDelegate = untypedExpr.Compile();
// Requires casting or DynamicInvoke for execution
</code></pre>
<h3 id="custom-type-conversions">Custom Type Conversions</h3>
<p>The system can be extended to handle custom type conversions with validation:</p>
<pre><code class="lang-csharp">private static Expression CreateParameterConversion(Expression source, Type targetType)
{
    // Handle nullable types
    if (targetType.IsGenericType &amp;&amp; targetType.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;))
    {
        var underlyingType = Nullable.GetUnderlyingType(targetType);
        return Expression.Convert(source, underlyingType);
    }
    
    // Handle custom conversions
    if (HasImplicitConversion(source.Type, targetType))
    {
        return Expression.Convert(source, targetType);
    }
    
    // Fallback to default conversion
    return Expression.Convert(source, targetType);
}
</code></pre>
<h3 id="generic-method-support">Generic Method Support</h3>
<p>Handling generic methods requires special consideration:</p>
<pre><code class="lang-csharp">internal static Func&lt;TInstance, object[], object&gt; CompileGenericMethod&lt;TInstance&gt;(
    MethodInfo method, Type[] genericArguments)
{
    if (method.IsGenericMethodDefinition)
    {
        // Create concrete generic method
        method = method.MakeGenericMethod(genericArguments);
    }
    
    // Rest of compilation logic...
    return CompileMethodInvoker&lt;TInstance, object&gt;(method);
}
</code></pre>
<h3 id="debugging-and-diagnostics">Debugging and Diagnostics</h3>
<pre><code class="lang-csharp">public static class ExpressionTreeDiagnostics
{
    public static string GetDebugView(Expression expression)
    {
        // Use internal DebugView property for detailed expression analysis
        var debugView = expression.GetType()
            .GetProperty(&quot;DebugView&quot;, BindingFlags.NonPublic | BindingFlags.Instance);
        return debugView?.GetValue(expression)?.ToString() ?? &quot;Debug view not available&quot;;
    }
    
    public static void LogCompilationMetrics(MethodInfo method, TimeSpan compilationTime)
    {
        Console.WriteLine($&quot;Compiled {method.Name} in {compilationTime.TotalMicroseconds}μs&quot;);
    }
}
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="common-issues">Common Issues</h3>
<ol>
<li><p><strong>Type Conversion Errors</strong>:</p>
<ul>
<li>Ensure parameter types match expected method signatures</li>
<li>Check for nullable reference type mismatches</li>
<li>Validate generic type constraints are satisfied</li>
</ul>
</li>
<li><p><strong>Compilation Failures</strong>:</p>
<ul>
<li>Verify method accessibility (public/internal)</li>
<li>Check for unsupported method signatures</li>
<li>Ensure all referenced assemblies are available</li>
<li>Validate expression tree represents a valid lambda expression</li>
</ul>
</li>
<li><p><strong>Performance Degradation</strong>:</p>
<ul>
<li>Monitor delegate cache size and memory usage</li>
<li>Profile compilation time vs execution frequency</li>
<li>Check for unnecessary recompilation of identical expressions</li>
</ul>
</li>
<li><p><strong>Variable Closure Issues</strong>:</p>
<ul>
<li>Avoid capturing <code>IDisposable</code> variables</li>
<li>Be careful with mutable reference types</li>
<li>Validate variable lifetimes match delegate usage</li>
</ul>
</li>
</ol>
<h3 id="debugging-tips">Debugging Tips</h3>
<ul>
<li><strong>Use expression debug views</strong>: <code>expression.ToString()</code> for readable representation</li>
<li><strong>Enable detailed exception messages</strong> in development builds</li>
<li><strong>Profile both compilation time and execution time</strong> to optimize caching strategy</li>
<li><strong>Test edge cases</strong> with different parameter types and method signatures</li>
<li><strong>Validate assembly dependencies</strong> are available at runtime</li>
</ul>
<h3 id="performance-profiling">Performance Profiling</h3>
<pre><code class="lang-csharp">public static class CompilationProfiler
{
    private static readonly ConcurrentDictionary&lt;string, CompilationMetrics&gt; _metrics = new();
    
    public static void RecordCompilation(string methodName, TimeSpan compilationTime, int delegateSize)
    {
        _metrics.AddOrUpdate(methodName, 
            new CompilationMetrics(compilationTime, delegateSize, 1),
            (key, existing) =&gt; existing.AddInvocation());
    }
    
    public static void PrintStatistics()
    {
        foreach (var kvp in _metrics)
        {
            var metrics = kvp.Value;
            Console.WriteLine($&quot;{kvp.Key}: {metrics.CompilationTime.TotalMicroseconds}μs, &quot; +
                            $&quot;{metrics.InvocationCount} calls, {metrics.DelegateSize} bytes&quot;);
        }
    }
}
</code></pre>
<h2 id="future-enhancements">Future Enhancements</h2>
<ul>
<li><strong>Source generators</strong>: Pre-compile delegates at build time to eliminate runtime compilation overhead</li>
<li><strong>Native AOT support</strong>: Optimize for ahead-of-time compilation scenarios where reflection is limited</li>
<li><strong>Advanced expression optimizations</strong>: Domain-specific IL generation optimizations</li>
<li><strong>Persistent caching</strong>: Serialize compiled delegates for faster application startup</li>
<li><strong>Compile-time validation</strong>: Static analysis to catch expression compilation issues at build time</li>
<li><strong>Custom IL emission</strong>: Direct IL generation for maximum performance in critical paths</li>
<li><strong>Expression tree pooling</strong>: Reuse expression tree objects to reduce GC pressure</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Compiled lambdas provide a powerful foundation for high-performance command execution in Jiro.Commands. By leveraging expression trees and the <code>LambdaExpression.Compile()</code> method, the system converts expression trees into executable Intermediate Language (IL) instructions, which are then JIT-compiled to native code for optimal performance.</p>
<p>Key benefits include:</p>
<ul>
<li><strong>Near-native performance</strong> after JIT compilation (200x faster than reflection)</li>
<li><strong>Type safety</strong> through strongly-typed delegates</li>
<li><strong>Memory efficiency</strong> with zero allocations per invocation</li>
<li><strong>JIT optimization benefits</strong> from static call sites and inlining opportunities</li>
</ul>
<p>The approach successfully bridges the gap between the flexibility required for dynamic command discovery and the performance demands of high-throughput command execution, making it an ideal solution for command-driven applications that need both runtime flexibility and optimal performance.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/HueByte/Jiro.Libs/blob/main/dev/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <div class="footer-custom"><div class="footer-inner d-flex justify-content-between align-items-center"><div class="footer-text">Made with <strong>💖</strong> By HueByte</div><div class="footer-links"><a href="https://github.com/HueByte/Jiro.Libs" class="footer-link" target="_blank"><i class="fab fa-github"></i>GitHub</a><a href="#" class="footer-link scroll-to-top" onclick="scrollToTop()"><i class="fas fa-arrow-up"></i>Top</a></div></div></div><script>function scrollToTop(){window.scrollTo({top:0,behavior:'smooth'});}</script>
        </div>
      </div>
    </footer>
  </body>
</html>
