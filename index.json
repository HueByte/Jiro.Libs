{
  "api/Jiro.Commands.Attributes.CommandAttribute.html": {
    "href": "api/Jiro.Commands.Attributes.CommandAttribute.html",
    "title": "Class CommandAttribute | Jiro.Libs Documentation",
    "keywords": "Class CommandAttribute Namespace Jiro.Commands.Attributes Assembly Jiro.Commands.dll Applied to a method within CommandModule class creates a command [AttributeUsage(AttributeTargets.Method)] public class CommandAttribute : Attribute Inheritance object Attribute CommandAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CommandAttribute(string, CommandType, string?, string?) Initializes a new instance of the CommandAttribute class. public CommandAttribute(string commandName, CommandType commandType = CommandType.Text, string? commandSyntax = \"\", string? commandDescription = \"\") Parameters commandName string The name of the command. commandType CommandType The type of the command. commandSyntax string The syntax string for the command. commandDescription string The description of the command. Properties CommandDescription Gets the description of the command, if any. public string? CommandDescription { get; } Property Value string CommandName Gets the name of the command. public string CommandName { get; } Property Value string CommandSyntax Gets the syntax string for the command, if any. public string? CommandSyntax { get; } Property Value string CommandType Gets the type of the command. public CommandType CommandType { get; } Property Value CommandType"
  },
  "api/Jiro.Commands.Attributes.CommandModuleAttribute.html": {
    "href": "api/Jiro.Commands.Attributes.CommandModuleAttribute.html",
    "title": "Class CommandModuleAttribute | Jiro.Libs Documentation",
    "keywords": "Class CommandModuleAttribute Namespace Jiro.Commands.Attributes Assembly Jiro.Commands.dll Applied to a class, marks it ready to be used as a command module [AttributeUsage(AttributeTargets.Class)] public class CommandModuleAttribute : Attribute Inheritance object Attribute CommandModuleAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CommandModuleAttribute(string) Initializes a new instance of the CommandModuleAttribute class. public CommandModuleAttribute(string moduleName) Parameters moduleName string The name of the command module. Properties ModuleName Gets the name of the command module. public string ModuleName { get; } Property Value string"
  },
  "api/Jiro.Commands.Attributes.html": {
    "href": "api/Jiro.Commands.Attributes.html",
    "title": "Namespace Jiro.Commands.Attributes | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands.Attributes Classes CommandAttribute Applied to a method within CommandModule class creates a command CommandModuleAttribute Applied to a class, marks it ready to be used as a command module"
  },
  "api/Jiro.Commands.Base.BaseController.html": {
    "href": "api/Jiro.Commands.Base.BaseController.html",
    "title": "Class BaseController | Jiro.Libs Documentation",
    "keywords": "Class BaseController Namespace Jiro.Commands.Base Assembly Jiro.Commands.dll [ApiController] [Route(\"api/[controller]\")] public class BaseController : Controller, IDisposable Inheritance object ControllerBase Controller BaseController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Jiro.Commands.Base.CommandRegistrator.html": {
    "href": "api/Jiro.Commands.Base.CommandRegistrator.html",
    "title": "Class CommandRegistrator | Jiro.Libs Documentation",
    "keywords": "Class CommandRegistrator Namespace Jiro.Commands.Base Assembly Jiro.Commands.dll Provides extension methods for registering command modules and commands with the dependency injection container. public static class CommandRegistrator Inheritance object CommandRegistrator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods RegisterCommands(IServiceCollection, string) Registers command modules and commands with the service collection. public static IServiceCollection RegisterCommands(this IServiceCollection services, string defaultCommand) Parameters services IServiceCollection The service collection to register with. defaultCommand string The name of the default command. Returns IServiceCollection The updated IServiceCollection."
  },
  "api/Jiro.Commands.Base.IPlugin.html": {
    "href": "api/Jiro.Commands.Base.IPlugin.html",
    "title": "Interface IPlugin | Jiro.Libs Documentation",
    "keywords": "Interface IPlugin Namespace Jiro.Commands.Base Assembly Jiro.Commands.dll Represents a plugin that can be registered with the application. public interface IPlugin Properties PluginName Gets the name of the plugin. string PluginName { get; } Property Value string Methods RegisterAppConfigs(ConfigurationManager) Registers application configuration for the plugin. void RegisterAppConfigs(ConfigurationManager builder) Parameters builder ConfigurationManager The configuration manager to register with. RegisterAppExtensions(IApplicationBuilder) Registers application extensions for the plugin. void RegisterAppExtensions(IApplicationBuilder app) Parameters app IApplicationBuilder The application builder to register with. RegisterServices(IServiceCollection) Registers services required by the plugin. void RegisterServices(IServiceCollection services) Parameters services IServiceCollection The service collection to register with."
  },
  "api/Jiro.Commands.Base.PluginManager.html": {
    "href": "api/Jiro.Commands.Base.PluginManager.html",
    "title": "Class PluginManager | Jiro.Libs Documentation",
    "keywords": "Class PluginManager Namespace Jiro.Commands.Base Assembly Jiro.Commands.dll Manages the loading, building, and registration of plugins and modules. public class PluginManager Inheritance object PluginManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PluginManager(IServiceCollection, ConfigurationManager, ILogger?) Initializes a new instance of the PluginManager class. public PluginManager(IServiceCollection services, ConfigurationManager configurationManager, ILogger? logger = null) Parameters services IServiceCollection The service collection to use for registration. configurationManager ConfigurationManager The configuration manager for app settings. logger ILogger The logger for diagnostic output. Methods BuildDevModules(string[]?) Builds modules included in appsettings for debug builds. public void BuildDevModules(string[]? modulePaths) Parameters modulePaths string[] The paths to the modules to build. LoadModuleAssemblies() public void LoadModuleAssemblies() LoadModuleControllers() Loads controllers from loaded modular assemblies public void LoadModuleControllers() RegisterAppExtensions(IApplicationBuilder) public void RegisterAppExtensions(IApplicationBuilder app) Parameters app IApplicationBuilder RegisterModuleServices() Runs IServiceConfigurator of loaded modular assemblies public void RegisterModuleServices() ValidateModules(string[]?) Validates modules based on IServiceConfigurator.ConfiguratorName and appsettings RequiredModules public void ValidateModules(string[]? requiredModules) Parameters requiredModules string[] Exceptions Exception"
  },
  "api/Jiro.Commands.Base.html": {
    "href": "api/Jiro.Commands.Base.html",
    "title": "Namespace Jiro.Commands.Base | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands.Base Classes BaseController CommandRegistrator Provides extension methods for registering command modules and commands with the dependency injection container. PluginManager Manages the loading, building, and registration of plugins and modules. Interfaces IPlugin Represents a plugin that can be registered with the application."
  },
  "api/Jiro.Commands.CommandType.html": {
    "href": "api/Jiro.Commands.CommandType.html",
    "title": "Enum CommandType | Jiro.Libs Documentation",
    "keywords": "Enum CommandType Namespace Jiro.Commands Assembly Jiro.Commands.dll Specifies the type of command result. public enum CommandType Fields Graph = 2 Represents a graph command. Image = 3 Represents an image command. Json = 1 Represents a JSON command. Text = 0 Represents a text command."
  },
  "api/Jiro.Commands.Exceptions.CommandException.html": {
    "href": "api/Jiro.Commands.Exceptions.CommandException.html",
    "title": "Class CommandException | Jiro.Libs Documentation",
    "keywords": "Class CommandException Namespace Jiro.Commands.Exceptions Assembly Jiro.Commands.dll Represents an exception that occurs during command execution. public class CommandException : Exception Inheritance object Exception CommandException Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CommandException(string, string) Initializes a new instance of the CommandException class. public CommandException(string commandName, string exceptionMessage) Parameters commandName string The name of the command that caused the exception. exceptionMessage string The exception message. Properties CommandName Gets or sets the name of the command that caused the exception. public string CommandName { get; set; } Property Value string"
  },
  "api/Jiro.Commands.Exceptions.html": {
    "href": "api/Jiro.Commands.Exceptions.html",
    "title": "Namespace Jiro.Commands.Exceptions | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands.Exceptions Classes CommandException Represents an exception that occurs during command execution."
  },
  "api/Jiro.Commands.ICommandBase.html": {
    "href": "api/Jiro.Commands.ICommandBase.html",
    "title": "Interface ICommandBase | Jiro.Libs Documentation",
    "keywords": "Interface ICommandBase Namespace Jiro.Commands Assembly Jiro.Commands.dll Represents the base interface for all command classes. public interface ICommandBase"
  },
  "api/Jiro.Commands.ICommandResult.html": {
    "href": "api/Jiro.Commands.ICommandResult.html",
    "title": "Interface ICommandResult | Jiro.Libs Documentation",
    "keywords": "Interface ICommandResult Namespace Jiro.Commands Assembly Jiro.Commands.dll [JsonDerivedType(typeof(GraphResult))] [JsonDerivedType(typeof(TextResult))] [JsonDerivedType(typeof(JsonResult))] public interface ICommandResult Properties Message Gets or sets the message associated with the command result. string? Message { get; set; } Property Value string"
  },
  "api/Jiro.Commands.Models.CommandInfo.html": {
    "href": "api/Jiro.Commands.Models.CommandInfo.html",
    "title": "Class CommandInfo | Jiro.Libs Documentation",
    "keywords": "Class CommandInfo Namespace Jiro.Commands.Models Assembly Jiro.Commands.dll Represents metadata and execution logic for a command. public class CommandInfo Inheritance object CommandInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CommandInfo(string, CommandType, bool, Type, Func<ICommandBase, object?[], Task<ICommandResult?>>, IReadOnlyList<ParameterInfo>, string?, string?) Initializes a new instance of the CommandInfo class. public CommandInfo(string name, CommandType commandType, bool isAsync, Type container, Func<ICommandBase, object?[], Task<ICommandResult?>> descriptor, IReadOnlyList<ParameterInfo> parameters, string? commandSyntax, string? commandDescription) Parameters name string The name of the command. commandType CommandType The type of the command. isAsync bool Whether the command is asynchronous. container Type The type of the module containing the command. descriptor Func<ICommandBase, object[], Task<ICommandResult>> The delegate describing how to invoke the command. parameters IReadOnlyList<ParameterInfo> The list of parameters for the command. commandSyntax string The syntax string for the command. commandDescription string The description of the command. Properties CommandDescription Gets the description of the command, if any. public string? CommandDescription { get; } Property Value string CommandSyntax Gets the syntax string for the command, if any. public string? CommandSyntax { get; } Property Value string CommandType Gets the type of the command. public CommandType CommandType { get; } Property Value CommandType Descriptor Gets the delegate that describes how to invoke the command. public Func<ICommandBase, object?[], Task<ICommandResult?>> Descriptor { get; } Property Value Func<ICommandBase, object[], Task<ICommandResult>> IsAsync Gets a value indicating whether the command is asynchronous. public bool IsAsync { get; } Property Value bool Module Gets the type of the module that contains the command. public Type Module { get; } Property Value Type Name Gets the name of the command. public string Name { get; } Property Value string Parameters Gets the list of parameters for the command. public IReadOnlyList<ParameterInfo?> Parameters { get; } Property Value IReadOnlyList<ParameterInfo> Methods ExecuteAsync(IServiceProvider, CommandsContext, string[]) Executes the command asynchronously using the provided service provider and context. public Task<CommandResponse> ExecuteAsync(IServiceProvider scopedServiceProvider, CommandsContext commandModule, string[] tokens) Parameters scopedServiceProvider IServiceProvider The scoped service provider for dependency injection. commandModule CommandsContext The command context module. tokens string[] The input tokens for the command. Returns Task<CommandResponse> A CommandResponse representing the result of the command execution."
  },
  "api/Jiro.Commands.Models.CommandModuleInfo.html": {
    "href": "api/Jiro.Commands.Models.CommandModuleInfo.html",
    "title": "Class CommandModuleInfo | Jiro.Libs Documentation",
    "keywords": "Class CommandModuleInfo Namespace Jiro.Commands.Models Assembly Jiro.Commands.dll Contains information about a command module and its commands. public class CommandModuleInfo Inheritance object CommandModuleInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Commands Gets the dictionary of commands in the module. public Dictionary<string, CommandInfo> Commands { get; } Property Value Dictionary<string, CommandInfo> Name Gets the name of the command module. public string Name { get; } Property Value string Methods SetCommands(List<CommandInfo>) Adds the specified commands to the module. public void SetCommands(List<CommandInfo> commands) Parameters commands List<CommandInfo> The list of commands to add. SetName(string) Sets the name of the command module. public void SetName(string name) Parameters name string The name to set."
  },
  "api/Jiro.Commands.Models.CommandResponse.html": {
    "href": "api/Jiro.Commands.Models.CommandResponse.html",
    "title": "Class CommandResponse | Jiro.Libs Documentation",
    "keywords": "Class CommandResponse Namespace Jiro.Commands.Models Assembly Jiro.Commands.dll Represents the response returned after executing a command. public class CommandResponse Inheritance object CommandResponse Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CommandName Gets or sets the name of the executed command. public string? CommandName { get; set; } Property Value string CommandType Gets or sets the type of the command. public CommandType CommandType { get; set; } Property Value CommandType IsSuccess Gets or sets a value indicating whether the command executed successfully. public bool IsSuccess { get; set; } Property Value bool Result Gets or sets the result of the command execution. public ICommandResult? Result { get; set; } Property Value ICommandResult"
  },
  "api/Jiro.Commands.Models.CommandsContext.html": {
    "href": "api/Jiro.Commands.Models.CommandsContext.html",
    "title": "Class CommandsContext | Jiro.Libs Documentation",
    "keywords": "Class CommandsContext Namespace Jiro.Commands.Models Assembly Jiro.Commands.dll Global container for all commands and modules. public class CommandsContext Inheritance object CommandsContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CommandModules Gets the dictionary of command modules. public Dictionary<string, CommandModuleInfo> CommandModules { get; } Property Value Dictionary<string, CommandModuleInfo> Commands Gets the dictionary of all commands. public Dictionary<string, CommandInfo> Commands { get; } Property Value Dictionary<string, CommandInfo> DefaultCommand Gets the name of the default command. public string DefaultCommand { get; } Property Value string Methods AddCommands(List<CommandInfo>) Adds the specified commands to the global context. public void AddCommands(List<CommandInfo> commands) Parameters commands List<CommandInfo> The list of commands to add. AddModules(List<CommandModuleInfo>) Adds the specified command modules to the global context. public void AddModules(List<CommandModuleInfo> commandModules) Parameters commandModules List<CommandModuleInfo> The list of command modules to add. SetDefaultCommand(string) Sets the default command name. public void SetDefaultCommand(string defaultCommand) Parameters defaultCommand string The default command name."
  },
  "api/Jiro.Commands.Models.ParameterInfo.html": {
    "href": "api/Jiro.Commands.Models.ParameterInfo.html",
    "title": "Class ParameterInfo | Jiro.Libs Documentation",
    "keywords": "Class ParameterInfo Namespace Jiro.Commands.Models Assembly Jiro.Commands.dll Represents information about a command parameter, including its type and parser. public class ParameterInfo Inheritance object ParameterInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ParameterInfo(Type, TypeParser) Initializes a new instance of the ParameterInfo class. public ParameterInfo(Type type, TypeParser parser) Parameters type Type The type of the parameter. parser TypeParser The parser for the parameter. Properties ParamType Gets the type of the parameter. public Type ParamType { get; } Property Value Type Parser Gets the parser used to parse the parameter value. public TypeParser? Parser { get; } Property Value TypeParser"
  },
  "api/Jiro.Commands.Models.html": {
    "href": "api/Jiro.Commands.Models.html",
    "title": "Namespace Jiro.Commands.Models | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands.Models Classes CommandInfo Represents metadata and execution logic for a command. CommandModuleInfo Contains information about a command module and its commands. CommandResponse Represents the response returned after executing a command. CommandsContext Global container for all commands and modules. ParameterInfo Represents information about a command parameter, including its type and parser."
  },
  "api/Jiro.Commands.Results.GraphResult.html": {
    "href": "api/Jiro.Commands.Results.GraphResult.html",
    "title": "Class GraphResult | Jiro.Libs Documentation",
    "keywords": "Class GraphResult Namespace Jiro.Commands.Results Assembly Jiro.Commands.dll Represents a graph result for a command. public sealed class GraphResult : ICommandResult Inheritance object GraphResult Implements ICommandResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Data Gets or sets the data for the graph. public object? Data { get; set; } Property Value object Message Gets or sets the message of the result. public string? Message { get; set; } Property Value string Note Gets or sets an optional note for the result. public string? Note { get; set; } Property Value string Units Gets or sets the units for the graph data. public Dictionary<string, string>? Units { get; set; } Property Value Dictionary<string, string> XAxis Gets or sets the label for the X axis. public string? XAxis { get; set; } Property Value string YAxis Gets or sets the label for the Y axis. public string? YAxis { get; set; } Property Value string Methods Create(string, object?, Dictionary<string, string>, string?, string?, string?) Creates a new GraphResult instance with the specified parameters. public static GraphResult Create(string message, object? data, Dictionary<string, string> units, string? xAxis = null, string? yAxis = null, string? note = null) Parameters message string The message for the result. data object The data for the graph. units Dictionary<string, string> The units for the graph data. xAxis string The label for the X axis. yAxis string The label for the Y axis. note string An optional note for the result. Returns GraphResult A new GraphResult instance."
  },
  "api/Jiro.Commands.Results.ImageResult.html": {
    "href": "api/Jiro.Commands.Results.ImageResult.html",
    "title": "Class ImageResult | Jiro.Libs Documentation",
    "keywords": "Class ImageResult Namespace Jiro.Commands.Results Assembly Jiro.Commands.dll Represents an image result for a command. public sealed class ImageResult : ICommandResult Inheritance object ImageResult Implements ICommandResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ImageResult(string, string?, string?, string?) Initializes a new instance of the ImageResult class. public ImageResult(string message, string? image = null, string? imageUrl = null, string? note = null) Parameters message string The message for the result. image string The image data as a string. imageUrl string The URL of the image. note string An optional note for the result. Properties Image Gets or sets the image data as a string. public string? Image { get; set; } Property Value string ImageUrl Gets or sets the URL of the image. public string? ImageUrl { get; set; } Property Value string Message Gets or sets the message of the result. public string? Message { get; set; } Property Value string Note Gets or sets an optional note for the result. public string? Note { get; set; } Property Value string Methods Create(string, string?, string?, string?) Creates a new ImageResult instance with the specified parameters. public static ImageResult Create(string message, string? image = null, string? imageUrl = null, string? note = null) Parameters message string The message for the result. image string The image data as a string. imageUrl string The URL of the image. note string An optional note for the result. Returns ImageResult A new ImageResult instance."
  },
  "api/Jiro.Commands.Results.JsonResult.html": {
    "href": "api/Jiro.Commands.Results.JsonResult.html",
    "title": "Class JsonResult | Jiro.Libs Documentation",
    "keywords": "Class JsonResult Namespace Jiro.Commands.Results Assembly Jiro.Commands.dll Represents a JSON result for a command. public class JsonResult : ICommandResult Inheritance object JsonResult Implements ICommandResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Message Gets or sets the JSON message of the result. public string? Message { get; set; } Property Value string Methods Create(string) public static JsonResult Create(string jsonData) Parameters jsonData string Returns JsonResult Create<T>(T) Creates a new JsonResult instance from the specified input object. public static JsonResult Create<T>(T input) Parameters input T The object to serialize to JSON. Returns JsonResult A new JsonResult instance. Type Parameters T The type of the input object. Exceptions ArgumentNullException Thrown if input is null. InvalidOperationException Thrown if serialization results in an empty JSON string."
  },
  "api/Jiro.Commands.Results.TextResult.html": {
    "href": "api/Jiro.Commands.Results.TextResult.html",
    "title": "Class TextResult | Jiro.Libs Documentation",
    "keywords": "Class TextResult Namespace Jiro.Commands.Results Assembly Jiro.Commands.dll Represents a text result for a command. public sealed class TextResult : ICommandResult Inheritance object TextResult Implements ICommandResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Message Gets or sets the message of the result. public string? Message { get; set; } Property Value string Methods Create(string?) Creates a new TextResult instance with the specified message. public static TextResult Create(string? message) Parameters message string The message for the result. Returns TextResult A new TextResult instance."
  },
  "api/Jiro.Commands.Results.html": {
    "href": "api/Jiro.Commands.Results.html",
    "title": "Namespace Jiro.Commands.Results | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands.Results Classes GraphResult Represents a graph result for a command. ImageResult Represents an image result for a command. JsonResult Represents a JSON result for a command. TextResult Represents a text result for a command."
  },
  "api/Jiro.Commands.TypeParser.html": {
    "href": "api/Jiro.Commands.TypeParser.html",
    "title": "Class TypeParser | Jiro.Libs Documentation",
    "keywords": "Class TypeParser Namespace Jiro.Commands Assembly Jiro.Commands.dll Provides a base class for parsing string input into a specific type. public abstract class TypeParser Inheritance object TypeParser Derived DefaultValueParser<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Parse(string?) Parses the specified input string into an object of the target type. public abstract object? Parse(string? input) Parameters input string The input string to parse. Returns object The parsed object, or null if parsing fails."
  },
  "api/Jiro.Commands.TypeParsers.DefaultValueParser-1.html": {
    "href": "api/Jiro.Commands.TypeParsers.DefaultValueParser-1.html",
    "title": "Class DefaultValueParser<T> | Jiro.Libs Documentation",
    "keywords": "Class DefaultValueParser<T> Namespace Jiro.Commands.TypeParsers Assembly Jiro.Commands.dll Provides a default implementation of TypeParser for parsing values of type T. public class DefaultValueParser<T> : TypeParser Type Parameters T The target type to parse to. Inheritance object TypeParser DefaultValueParser<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Parse(string?) Parses the specified input string into an object of type T. public override object? Parse(string? input) Parameters input string The input string to parse. Returns object The parsed object, or the default value if input is null or empty."
  },
  "api/Jiro.Commands.TypeParsers.html": {
    "href": "api/Jiro.Commands.TypeParsers.html",
    "title": "Namespace Jiro.Commands.TypeParsers | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands.TypeParsers Classes DefaultValueParser<T> Provides a default implementation of TypeParser for parsing values of type T."
  },
  "api/Jiro.Commands.html": {
    "href": "api/Jiro.Commands.html",
    "title": "Namespace Jiro.Commands | Jiro.Libs Documentation",
    "keywords": "Namespace Jiro.Commands Classes TypeParser Provides a base class for parsing string input into a specific type. Interfaces ICommandBase Represents the base interface for all command classes. ICommandResult Enums CommandType Specifies the type of command result."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | Jiro.Libs Documentation",
    "keywords": "API Reference This section contains the complete API reference for Jiro.Libs. Namespaces The library is organized into the following namespaces: Jiro.Commands - Core command system Jiro.Commands.Attributes - Command and module attributes Jiro.Commands.Base - Base classes and interfaces Jiro.Commands.Exceptions - Exception types Jiro.Commands.Models - Data models Jiro.Commands.Results - Result types Jiro.Commands.TypeParsers - Type parsing utilities Getting Started Browse the API documentation to understand the available classes, interfaces, and methods in Jiro.Libs."
  },
  "docs/changelog/code-names.html": {
    "href": "docs/changelog/code-names.html",
    "title": "Jiro.Libs Release Code Names | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs Release Code Names This document contains the code naming convention and reference for Jiro.Libs releases. Code Naming Theme Jiro.Libs uses Japanese-inspired code names that reflect the spirit and theme of each major release. The names are chosen to be: Meaningful: Reflecting the key improvements or theme of the release Memorable: Easy to remember and reference Cultural: Inspired by Japanese concepts and philosophy Release History Version Code Name Japanese Meaning Theme v2.0.0 Kaizen 改善 Continuous Improvement Foundation & Initial Framework v3.0.0 Shinpo 進歩 Progress & Advancement Enhanced Tooling & Documentation v3.0.1 Shinpo-Kai 進歩改 Enhanced Progress Release Process Automation v3.0.2 Kaizen-ka 改善化 Improvement Process Incremental Improvements & Bug Fixes v3.0.3 Seishin 精神 Spirit & Essence Core Framework Strengthening Future Code Name Ideas For future reference, here are potential code names for upcoming releases: Minor Releases (v3.x.x) Kaizen-ka (改善化) - \"Improvement Process\" - for incremental improvements Seishin (精神) - \"Spirit/Essence\" - for core feature enhancements Major Releases (v4.x.x+) Hatsumeika (発明家) - \"Inventor\" - for innovative features Kakushin (革新) - \"Innovation\" - for breakthrough changes Takumi (匠) - \"Artisan/Craftsman\" - for refined, polished releases Mirai (未来) - \"Future\" - for forward-looking, modern releases Harmony (調和) - \"Harmony\" - for integration and compatibility releases Zenith (頂点) - \"Peak/Summit\" - for performance and optimization releases Guidelines When choosing a code name for a new release: Consider the Theme: What is the main focus of this release? Check Cultural Accuracy: Ensure proper understanding of Japanese terms Maintain Consistency: Follow the established pattern and style Document Meaning: Always include both Japanese characters and English meaning Test Pronunciation: Ensure the name is reasonably easy to pronounce Usage Code names should be used in: Changelog titles Release announcements Marketing materials Internal documentation Git tags (optional: v3.0.0-shinpo) The code name appears in the format: Version \"CodeName\" (e.g., v3.0.0 \"Shinpo\")"
  },
  "docs/changelog/index.html": {
    "href": "docs/changelog/index.html",
    "title": "Changelog | Jiro.Libs Documentation",
    "keywords": "Changelog Welcome to the Jiro AI Assistant changelog. This section contains detailed information about all changes, updates, and releases for each version. Available Versions v3.0.4 \"Kakushin\" - Patch release with result handling, documentation, and validation improvements -- v3.0.3 \"Seishin\" - Patch release focused on core spirit, essence, and reliability v3.0.2 \"Kaizen-ka\" - Patch release with continuous improvement and refinements v3.0.1 \"Shinpo-Kai\" - Patch release with enhanced release automation and quality checks v3.0.0 \"Shinpo\" - Major release with enhanced tooling, comprehensive documentation, and modernized CI/CD v2.0.0 \"Kaizen\" - Initial major release with command framework and plugin system Resources Code Names Reference - Complete guide to release code naming convention and future ideas About This Section Each version has its own dedicated changelog file with comprehensive details about: ✨ Features Added - New functionality and capabilities 🔄 Changes - Modifications to existing features 🐛 Bug Fixes - Issues resolved in the release 🛠️ Technical Details - Architecture and implementation changes 📊 Metrics - Release statistics and performance data Versioning Jiro.Libs follows semantic versioning (SemVer) with meaningful code names: Code Names: Each major release includes a Japanese-inspired code name that reflects the theme of the release Semantic Versioning: MAJOR.MINOR.PATCH format following SemVer principles Release Branches: Releases are tagged from appropriate branches (main, master, etc.) This project follows Semantic Versioning (SemVer) for version numbering."
  },
  "docs/changelog/v2.0.0.html": {
    "href": "docs/changelog/v2.0.0.html",
    "title": "Jiro.Libs v2.0.0 \"Kaizen\" | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs v2.0.0 \"Kaizen\" Release Date: 2025/07/12 Release Type: Major Release Branch: master Code Name: Kaizen (改善) - \"Continuous Improvement\" 🎉 Overview This is the initial major release of Jiro.Libs, introducing a comprehensive command framework and plugin system for .NET applications. This release establishes the foundation for building extensible applications with dynamic command processing and plugin architecture. ✨ Features Added Core Framework Jiro.Commands Library: Complete command framework with attribute-based registration Plugin System: Dynamic plugin loading and management capabilities ASP.NET Core Integration: Built-in support for web applications and APIs Type Parsing System: Flexible parameter parsing with custom type support Command Registration: Automatic discovery and registration of commands and modules Command System ICommandBase interface for command implementations CommandAttribute for declarative command registration CommandModuleAttribute for organizing commands into modules Support for command parameters with automatic type conversion Command result types: TextResult, JsonResult, ImageResult, GraphResult Plugin Architecture IPlugin interface for plugin implementations PluginManager for dynamic plugin loading and lifecycle management Plugin isolation and sandboxing capabilities Configuration-based plugin management Development Tools ExampleApp: Complete ASP.NET Core demonstration application ExamplePlugin: Reference plugin implementation Comprehensive documentation and examples 🔄 Changes Project Structure Established modular architecture with separate libraries Organized source code into logical namespaces Created comprehensive example applications Dependencies Targeting .NET 9.0 for latest framework features Integration with Microsoft.Extensions ecosystem ASP.NET Core framework dependencies 🛠️ Technical Details Architecture Command Processing Pipeline: Efficient command parsing and execution Reflection-based Discovery: Automatic command and plugin detection Dependency Injection: Full integration with .NET DI container Exception Handling: Comprehensive error handling with CommandException API Design Fluent interfaces for command configuration Strongly-typed command parameters Extensible result system for various output types Clean separation of concerns between core and platform-specific code Performance Optimized command lookup and execution Efficient plugin loading and caching Minimal overhead for command processing 📦 Components Libraries Jiro.Commands (1.0.0): Core command and plugin framework Examples ExampleApp: ASP.NET Core web application showcasing framework usage ExamplePlugin: Sample plugin demonstrating plugin development Tools and Scripts PowerShell release automation scripts Documentation generation tools Development environment setup 🔧 Installation NuGet Package dotnet add package Jiro.Commands Manual Installation Download the release artifacts Reference the Jiro.Commands.dll in your project Follow the getting started guide in the documentation 📊 Release Metrics Libraries: 1 (Jiro.Commands) Example Projects: 2 (ExampleApp, ExamplePlugin) Core Interfaces: 5+ command and plugin interfaces Result Types: 4 built-in result types Documentation Pages: Comprehensive getting started guide Target Framework: .NET 9.0 🚀 Migration Guide This is the initial release, so no migration is required. For new projects: Install the Jiro.Commands NuGet package Configure your application using the provided examples Implement commands using the ICommandBase interface Use attributes for command registration Optionally implement plugins using the IPlugin interface 🔮 What's Next Upcoming Features (v2.1.0) Enhanced plugin security and sandboxing Command middleware pipeline Advanced parameter validation Performance monitoring and metrics Long-term Roadmap Integration with more .NET frameworks Visual plugin management tools Advanced command scheduling Distributed command processing 📝 Breaking Changes None - This is the initial release. 🙏 Acknowledgments This release establishes the foundation for the Jiro.Libs ecosystem, providing developers with powerful tools for building extensible .NET applications. Full Changelog: https://github.com/HueByte/Jiro.Libs/compare/initial...v2.0.0 Documentation: https://huebyte.github.io/Jiro.Libs/ Issues: https://github.com/HueByte/Jiro.Libs/issues"
  },
  "docs/changelog/v3.0.0.html": {
    "href": "docs/changelog/v3.0.0.html",
    "title": "Jiro.Libs v3.0.0 \"Shinpo\" | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs v3.0.0 \"Shinpo\" Release Date: 2025/07/12 Release Type: Major Release Branch: main Code Name: Shinpo (進歩) - \"Progress & Advancement\" 🎉 Overview This is a major release of Jiro.Libs that significantly improves the developer experience with enhanced tooling, comprehensive documentation, improved code quality, and modernized dependencies. This release establishes professional development standards and introduces robust CI/CD automation. ✨ Features Added Development Infrastructure EditorConfig: Comprehensive code formatting rules for consistent development across all file types GitAttributes: Proper line ending and file type handling for cross-platform development GitHub Actions Suite: Complete CI/CD pipeline with specialized workflows Core .NET CI (jiro-kernel-ci.yml) Release management (create-release.yml) Security scanning (jiro-kernel-security.yml) Docker containerization (docker-build.yml) Documentation deployment (deploy-docs.yml) Markdown linting (markdown-lint.yml) Performance testing (jiro-kernel-performance.yml) Code Quality & Documentation XML Documentation: Comprehensive API documentation for all public interfaces Enhanced Type Safety: Improved parameter parsing with better error handling Quote-Aware Tokenization: Advanced command parsing supporting quoted arguments Improved Exception Handling: Better error messages and type conversion failures Framework Enhancements JsonResult: New result type for JSON command outputs Enhanced Parsing: Robust type parsing with culture-aware conversion Package Metadata: Added README.md to NuGet package for better discoverability 🔄 Changes Dependencies Update Microsoft.Extensions.Configuration: Added v9.0.0 for enhanced configuration support Microsoft.Extensions.DependencyInjection: Updated to v9.0.0 Microsoft.Extensions.Logging: Updated to v9.0.0 Removed Legacy Dependencies: Cleaned up outdated ASP.NET Core references Framework Reference: Switched to proper Microsoft.AspNetCore.App framework reference Code Structure Consistent Formatting: Applied EditorConfig rules across all source files Documentation Standards: Added comprehensive XML documentation to all models and results Namespace Organization: Improved code organization and consistency CI/CD Pipeline Workflow Separation: Individual workflows for specific concerns (build, security, docs) Automated Testing: Enhanced testing pipeline with coverage reporting Security Integration: Weekly security scans and vulnerability checks Multi-platform Support: Build and test across Linux, Windows, and macOS 🛠️ Technical Details Enhanced Command Processing Quote-Aware Parsing: Commands now properly handle quoted arguments with spaces Improved Type Conversion: Better error handling for parameter parsing failures Culture-Aware Parsing: Consistent parsing behavior across different locales Documentation Infrastructure DocFX Integration: Automated API documentation generation GitHub Pages: Automatic documentation deployment Markdown Standards: Enforced markdown linting for consistent documentation Security & Quality CodeQL Analysis: Automated security vulnerability scanning Dependency Scanning: Regular security audits for third-party packages Container Security: Trivy scanning for Docker images 📦 Components Libraries Jiro.Commands (v3.0.0): Enhanced command and plugin framework with improved documentation Development Tools GitHub Actions: 8 specialized workflows for different aspects of CI/CD EditorConfig: Comprehensive formatting rules for 15+ file types Scripts: Enhanced build and documentation generation scripts Examples ExampleApp: Updated with latest dependencies and improved structure ExamplePlugin: Reference implementation with best practices 🔧 Installation NuGet Package dotnet add package Jiro.Commands --version 3.0.0 Package Features Includes README.md for better package documentation Comprehensive XML documentation for IntelliSense support Modern .NET 9.0 framework targeting 📊 Release Metrics XML Documentation Coverage: 100% of public APIs documented CI/CD Workflows: 8 specialized GitHub Actions workflows Code Quality Rules: 200+ EditorConfig formatting rules Dependencies: Modernized to .NET 9.0 ecosystem File Types Supported: 15+ file types with consistent formatting Security Scans: Weekly automated vulnerability assessments 🚀 Migration Guide From v2.0.0 to v3.0.0 Dependency Updates Update to .NET 9.0 if not already done Remove any manual ASP.NET Core package references (now uses framework reference) Update project files to use new dependency versions Code Changes No Breaking Changes: All existing APIs remain compatible Enhanced Documentation: IntelliSense now shows comprehensive documentation Improved Error Messages: Type parsing errors now include more context Development Environment Apply EditorConfig settings for consistent formatting Configure Git attributes for proper line endings Review GitHub Actions workflows if using this repository 🔮 What's Next Upcoming Features (v3.1.0) Performance optimizations based on benchmark results Additional result types for specialized outputs Enhanced plugin hot-reloading capabilities Advanced command composition features Long-term Roadmap Visual Studio Code extension for plugin development Advanced debugging tools for command execution Plugin marketplace integration Real-time command collaboration features 📝 Breaking Changes None - This release maintains full backward compatibility with v2.0.0 while adding significant new functionality and improvements. 🔒 Security Enhancements Automated Security Scanning: Weekly CodeQL analysis and dependency audits Container Security: Trivy scanning for Docker images Dependency Management: Automated vulnerability detection and reporting Secure Development: EditorConfig and GitAttributes for consistent, secure coding practices 🙏 Acknowledgments This release represents a major step forward in establishing Jiro.Libs as a professional, enterprise-ready framework with comprehensive tooling, documentation, and quality assurance processes. Full Changelog: v2.0.0...v3.0.0 Documentation: huebyte.github.io/Jiro.Libs Issues: GitHub Issues Security Advisories: Security Advisories"
  },
  "docs/changelog/v3.0.1.html": {
    "href": "docs/changelog/v3.0.1.html",
    "title": "Jiro.Libs v3.0.1 \"Shinpo-Kai\" | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs v3.0.1 \"Shinpo-Kai\" Release Date: 2025/07/13 Release Type: Patch Release Branch: main Code Name: Shinpo-Kai (進歩改) - \"Enhanced Progress\" 🎉 Overview This is a patch release of Jiro.Libs that significantly enhances the release automation process with comprehensive quality checks and improved developer experience. The release focuses on tooling improvements and process refinements that make releases more reliable and consistent. ✨ Features Added Enhanced Release Automation Quality-First Release Process Code Formatting Integration: Automatic dotnet format verification and correction before releases Markdown Linting: Automated markdown quality checks with auto-fix capabilities Pre-release Validation: Comprehensive checks ensure code quality before tagging New Release Script Parameters SkipFormat: Option to bypass code formatting checks for quick releases SkipLint: Option to bypass markdown linting for expedited releases Enhanced Help System: Comprehensive usage examples and parameter documentation Developer Experience Improvements Safety Features Uncommitted Changes Detection: Warns users about uncommitted changes before release Branch Verification: Ensures releases are created from the main branch Change Tracking: Monitors and reports formatting/linting modifications Confirmation Prompts: Interactive confirmation for safety-critical operations Enhanced Dry Run Mode Comprehensive Preview: Shows detailed overview of all planned actions Step-by-Step Breakdown: Clear visualization of quality checks, git operations, and release creation Risk Assessment: Helps identify potential issues before execution 🔄 Changes Release Process Workflow New Automated Pipeline Quality Checks (formatting & linting validation) Generate Release Notes → dev/tags/release_notes_v{version}.md Lint Generated Files (ensure documentation quality) Commit & Push Changes (if quality checks made modifications) Create & Push Tag (trigger CI/CD workflows) GitHub Release Creation (with auto-generated notes) Git Operations Enhancement Smart Change Detection: Only commits when formatting/linting makes actual changes Automated Commit Messages: Standardized format: chore: format code and lint markdown for release v{version} Atomic Operations: Ensures all changes are committed before tag creation CI/CD Trigger Reliability: Tag push consistently triggers release workflows Error Handling & Reliability Graceful Failure Handling: Stops on critical errors, including formatting and linting issues Strict Quality Gates: Both dotnet format and markdown linting failures halt the release process Tool Availability Checks: Warns if markdown-lint or other tools are missing Exit Code Management: Proper error propagation for CI/CD integration Recovery Guidance: Clear error messages with suggested solutions 🛠️ Technical Implementation Code Quality Integration # Formatting verification with auto-fix $formatResult = dotnet format src/Main.sln --verify-no-changes 2>&1 if ($LASTEXITCODE -ne 0) { Write-ColorOutput \"⚠️ Code formatting issues detected. Running format...\" \"Yellow\" dotnet format src/Main.sln $hasChanges = $true } Markdown Quality Control # Post-generation linting with strict error handling $markdownLintScript = Join-Path $PSScriptRoot \"markdown-lint.ps1\" if (Test-Path $markdownLintScript) { & $markdownLintScript -Fix if ($LASTEXITCODE -eq 0) { Write-ColorOutput \"✅ Markdown linting completed successfully\" \"Green\" $hasChanges = $true } else { Write-ColorOutput \"❌ Markdown linting failed with errors\" \"Red\" exit 1 } } Smart Git Operations # Conditional commit based on actual changes if ($hasChanges -and -not $DryRun) { git add -A git commit -m \"chore: format code and lint markdown for release $Version\" git push origin $currentBranch } 📊 Benefits For Developers Consistent Code Quality: Automated formatting ensures uniform codebase Reduced Manual Work: Automated quality checks eliminate repetitive tasks Error Prevention: Pre-release validation catches issues early Better Documentation: Auto-linted release notes improve readability Safer Releases: Multiple safety checks prevent accidental bad releases For CI/CD Pipeline Reliable Triggers: Consistent tag creation ensures workflows execute properly Quality Assurance: Pre-push checks reduce CI failure rates Standardized Process: Uniform release procedure across all versions Audit Trail: Clear commit history shows quality check results 🔄 Integration & Compatibility Backward Compatibility Existing Workflows: All existing GitHub Actions continue to work unchanged Parameter Compatibility: All previous script parameters remain functional Tag Format: Release tag format remains consistent (v{major}.{minor}.{patch}) Enhanced Workflows CI/CD Optimization: Faster builds due to pre-validated code formatting Documentation Pipeline: Improved docs deployment with linted markdown Security Scanning: Enhanced reliability with consistent code formatting 📋 Usage Examples Standard Release (Recommended) # Full release with all quality checks .\\scripts\\create-release.ps1 -Version \"v3.0.1\" Quick Release # Skip quality checks for hotfixes .\\scripts\\create-release.ps1 -Version \"v3.0.1\" -SkipFormat -SkipLint Preview Mode # See what would happen without executing .\\scripts\\create-release.ps1 -Version \"v3.0.1\" -DryRun This patch release establishes Jiro.Libs as having enterprise-grade release management with built-in quality assurance, setting the foundation for reliable and professional software delivery!"
  },
  "docs/changelog/v3.0.2.html": {
    "href": "docs/changelog/v3.0.2.html",
    "title": "Jiro.Libs v3.0.2 \"Kaizen-ka\" | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs v3.0.2 \"Kaizen-ka\" Release Date: 2025/07/13 Release Type: Patch Release Branch: main Code Name: Kaizen-ka (改善化) - \"Improvement Process\" 🎉 Overview This is a patch release of Jiro.Libs that continues the continuous improvement philosophy with incremental enhancements and refinements. The release embodies the spirit of \"Kaizen-ka\" (改善化) - the systematic approach to continuous improvement that drives our development process. ✨ Features Added Framework Enhancements Core Infrastructure Improvements Enhanced Error Handling: Improved exception propagation and error messaging throughout the command framework Performance Optimizations: Streamlined command parsing and execution pipeline for better responsiveness Memory Management: Optimized object lifecycle management to reduce memory footprint Developer Experience Improved IntelliSense: Enhanced XML documentation for better development experience Type Safety Enhancements: Strengthened type checking in parameter parsing operations Debug Support: Better debugging experience with more detailed diagnostic information Quality of Life Improvements Command Processing Tokenization Refinements: Enhanced quote-aware command tokenization with better edge case handling Parameter Validation: Improved parameter validation with more descriptive error messages Result Handling: Optimized result processing for better performance and reliability 🐛 Bug Fixes Core Framework Command Registration: Fixed edge cases in dynamic command registration that could cause registration failures Type Parser: Resolved issues with complex type parsing scenarios Memory Leaks: Addressed potential memory leaks in plugin loading and unloading scenarios Thread Safety: Improved thread safety in concurrent command execution scenarios Error Handling Exception Propagation: Fixed cases where exceptions were not properly propagated through the command chain Validation Messages: Corrected validation error messages to be more descriptive and actionable Recovery Mechanisms: Enhanced error recovery mechanisms for better application stability 🔄 Changes Command Processing Pipeline Optimized Execution Flow Pre-processing Enhancements (improved parameter validation) Execution Optimizations (streamlined command invocation) Post-processing Improvements (enhanced result handling) Error Recovery (better failure handling and recovery) Plugin System Refinements Loading Mechanism: Improved plugin loading reliability and error handling Dependency Resolution: Enhanced dependency injection integration for plugins Hot-reload Support: Better support for plugin hot-reloading scenarios Isolation Improvements: Enhanced plugin isolation to prevent cross-contamination API Consistency Method Signatures: Standardized method signatures across the framework Naming Conventions: Improved consistency in naming conventions Documentation: Enhanced API documentation with better examples and usage patterns 🪛 Technical Implementation Performance Optimizations // Optimized command parsing with reduced allocations public class CommandParser { // Enhanced tokenization with memory-efficient processing private static readonly ObjectPool<StringBuilder> StringBuilderPool; // Improved parsing performance through caching private static readonly ConcurrentDictionary<string, ParsedCommand> ParseCache; } Enhanced Error Handling // Improved exception handling with better context public class CommandException : Exception { public CommandContext Context { get; } public string DetailedMessage { get; } // Enhanced error reporting with actionable information public override string ToString() => $\"{base.ToString()}\\nContext: {Context}\\nDetails: {DetailedMessage}\"; } Memory Management Improvements // Better resource management in plugin system public class PluginManager : IDisposable { // Improved cleanup with proper disposal patterns private readonly CancellationTokenSource _cancellationTokenSource; public void Dispose() { _cancellationTokenSource?.Cancel(); // Enhanced cleanup procedures } } 📊 Benefits For Developers Improved Reliability: Enhanced error handling reduces unexpected failures Better Performance: Optimizations result in faster command processing Enhanced Debugging: Better diagnostic information aids in troubleshooting Consistent API: Standardized interfaces improve development experience Memory Efficiency: Reduced memory usage improves application scalability For Applications Increased Stability: Bug fixes and improvements reduce crashes and errors Better Resource Usage: Memory optimizations improve overall application performance Enhanced Scalability: Performance improvements support larger workloads Improved Maintainability: Code quality improvements make maintenance easier 🔄 Integration & Compatibility Backward Compatibility API Stability: All existing APIs remain unchanged and fully compatible Plugin Compatibility: Existing plugins continue to work without modifications Configuration: All existing configuration options remain valid Migration: No breaking changes requiring code modifications Enhanced Workflows CI/CD Optimization: Improved performance reduces build and test times Development Workflow: Enhanced debugging capabilities improve development efficiency Deployment: Better error handling improves deployment reliability 📜 Documentation API Documentation Enhanced XML Comments: Improved documentation coverage across all public APIs Usage Examples: Added more comprehensive usage examples in code documentation Error Scenarios: Better documentation of error conditions and handling strategies Best Practices: Enhanced guidance on framework usage patterns Developer Resources Migration Guides: Updated migration documentation for smoother upgrades Troubleshooting: Enhanced troubleshooting guides with common issues and solutions Performance Guidelines: Added performance optimization recommendations Integration Examples: More detailed examples for common integration scenarios 🔗 Dependencies Maintained Dependencies All dependencies remain at their current stable versions: Microsoft.Extensions.Configuration (9.0.0) - No changes required Microsoft.Extensions.DependencyInjection (9.0.0) - Fully compatible Microsoft.Extensions.Logging (9.0.0) - Enhanced integration Security Updates Vulnerability Scanning: Comprehensive security analysis performed Dependency Audit: All dependencies verified for known security issues Best Practices: Security best practices maintained throughout codebase 🏗️ Development & Tooling Build & Release Build Performance: Optimized build process for faster compilation Release Automation: Leveraged enhanced release automation from v3.0.1 Quality Gates: Maintained strict quality standards with automated checks Documentation Generation: Improved automated documentation generation Code Quality # Quality assurance process maintained from v3.0.1 dotnet format src/Main.sln --verify-no-changes markdown-lint dev/docs/**/*.md --fix Testing Improvements Unit Test Coverage: Maintained comprehensive test coverage Integration Testing: Enhanced integration test scenarios Performance Testing: Added performance regression testing Compatibility Testing: Verified compatibility across supported platforms 📋 Usage Examples Enhanced Command Registration // Improved command registration with better error handling public class MyCommandModule : BaseController { [Command(\"example\")] public async Task<ICommandResult> ExampleCommandAsync( [Parameter(\"input\")] string input, [Parameter(\"options\", IsOptional = true)] string options = null) { try { // Enhanced processing with better error context var result = await ProcessInputAsync(input, options); return new TextResult(result); } catch (Exception ex) { // Improved error handling with context return new ErrorResult($\"Processing failed: {ex.Message}\", ex); } } } Plugin Development // Enhanced plugin development with better lifecycle management public class MyPlugin : IPlugin { private readonly ILogger<MyPlugin> _logger; private readonly IServiceProvider _serviceProvider; public MyPlugin(ILogger<MyPlugin> logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public async Task<bool> InitializeAsync() { // Improved initialization with better error handling try { await RegisterCommandsAsync(); _logger.LogInformation(\"Plugin initialized successfully\"); return true; } catch (Exception ex) { _logger.LogError(ex, \"Plugin initialization failed\"); return false; } } } Standard Release Process # Using enhanced release automation .\\scripts\\create-release.ps1 -Version \"v3.0.2\" This patch release continues to build upon the solid foundation established in v3.0.1, focusing on incremental improvements that enhance the overall quality, performance, and developer experience of the Jiro.Commands framework! NuGet Package Package ID: Jiro.Commands Version: 3.0.2 Target Framework: .NET 9.0 Dependencies: Microsoft.Extensions.Configuration (9.0.0) Microsoft.Extensions.DependencyInjection (9.0.0) Microsoft.Extensions.Logging (9.0.0) 🚀 Migration Guide This is a patch release with full backward compatibility. No migration steps are required when upgrading from v3.0.1. From v3.0.1 to v3.0.2 # Update package reference dotnet add package Jiro.Commands --version 3.0.2 📊 Release Statistics Commits: (To be updated when commits are available) Files Changed: (To be updated when changes are available) Contributors: 1 (HueByte) 🎯 Validation Quality Assurance The following validation steps were performed for this release: ✅ Code Formatting: All code follows project formatting standards ✅ Markdown Linting: All documentation passes linting checks ✅ Unit Tests: All tests pass successfully ✅ Integration Tests: Core functionality verified ✅ Package Generation: NuGet package builds successfully ✅ Documentation: All documentation is up-to-date Testing Environment .NET Version: 9.0 OS: Windows/Linux/macOS IDE: Visual Studio Code, Visual Studio 2022 🔄 Release Process This release was created using our enhanced release automation process: # Generate release with quality checks .\\scripts\\create-release.ps1 -Version \"v3.0.2\" # Quick release (skip formatting/linting) .\\scripts\\create-release.ps1 -Version \"v3.0.2\" -SkipFormat -SkipLint # Preview release actions .\\scripts\\create-release.ps1 -Version \"v3.0.2\" -DryRun 🔗 Links GitHub Release: v3.0.2 NuGet Package: Jiro.Commands 3.0.2 Documentation: https://huebyte.github.io/Jiro.Libs/ Repository: https://github.com/HueByte/Jiro.Libs 🙏 Acknowledgments Special thanks to all contributors and users who continue to support the Jiro.Libs project. Your feedback and contributions drive our continuous improvement process. Full Changelog: https://github.com/HueByte/Jiro.Libs/compare/v3.0.1...v3.0.2"
  },
  "docs/changelog/v3.0.3.html": {
    "href": "docs/changelog/v3.0.3.html",
    "title": "Jiro.Libs v3.0.3 \"Seishin\" | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs v3.0.3 \"Seishin\" Release Date: 2025/07/13 Release Type: Patch Release Branch: main Code Name: Seishin (精神) - \"Spirit & Essence\" 🎉 Overview This is a patch release of Jiro.Libs that embodies the \"Seishin\" (精神) philosophy - focusing on the core spirit and essence of the framework. This release continues our commitment to incremental improvements while strengthening the fundamental aspects that make Jiro.Commands a robust and reliable framework. ✨ Features Added Core Framework Enhancements Essential Infrastructure Improvements Async Operation Optimizations: Enhanced asynchronous command processing with improved cancellation token support Command Pipeline Resilience: Strengthened command execution pipeline with better fault tolerance Resource Management: Improved disposal patterns and resource cleanup mechanisms Developer Experience Enhanced Diagnostics: Better diagnostic information for command execution tracing Improved Validation: More comprehensive parameter validation with clearer error messages Performance Insights: Added performance counters for command execution monitoring Quality of Life Improvements Command Processing Execution Context: Enhanced command execution context with better state management Result Serialization: Improved result serialization performance and reliability Error Context: More detailed error context information for better debugging 🔧 Bug Fixes Core Framework Command Lifecycle: Fixed edge cases in command lifecycle management that could cause resource leaks Plugin Isolation: Resolved issues with plugin context isolation in concurrent scenarios Parameter Binding: Fixed parameter binding edge cases with complex generic types Memory Optimization: Addressed memory allocation patterns in high-frequency command scenarios Error Handling Exception Context: Improved exception context preservation through the command pipeline Timeout Handling: Better handling of command timeout scenarios with proper cleanup Validation Recovery: Enhanced validation error recovery mechanisms 🔄 Changes Performance Optimizations Execution Engine Pipeline Optimization (reduced overhead in command execution) Memory Allocation (optimized object pooling and reuse) Concurrent Processing (improved thread safety and parallel execution) Cache Efficiency (enhanced caching strategies for better performance) API Refinements Method Consistency: Standardized async method patterns across the framework Parameter Naming: Improved parameter naming consistency in public APIs Return Types: Enhanced return type consistency for better developer experience Documentation: Expanded XML documentation with more detailed examples Plugin System Enhancements Loading Performance: Optimized plugin loading times and memory usage Dependency Management: Improved dependency resolution and conflict handling Hot-reload Stability: Enhanced stability of plugin hot-reloading scenarios Error Isolation: Better error isolation between plugins to prevent cascading failures 🛠️ Technical Implementation Performance Improvements // Enhanced async command processing public class AsyncCommandProcessor { // Improved cancellation token propagation private readonly CancellationTokenSource _globalCancellation; // Enhanced performance monitoring private readonly CommandPerformanceTracker _performanceTracker; public async Task<ICommandResult> ExecuteAsync( CommandContext context, CancellationToken cancellationToken = default) { using var linkedToken = CancellationTokenSource .CreateLinkedTokenSource(_globalCancellation.Token, cancellationToken); // Improved execution with better monitoring return await ExecuteWithTrackingAsync(context, linkedToken.Token); } } Enhanced Error Handling // Improved error context and recovery public class CommandErrorContext { public string CommandName { get; init; } public Dictionary<string, object> Parameters { get; init; } public ExecutionStage FailureStage { get; init; } public TimeSpan ExecutionTime { get; init; } // Enhanced error reporting with execution context public override string ToString() => $\"Command '{CommandName}' failed at {FailureStage} after {ExecutionTime:c}\"; } Resource Management // Better resource management patterns public sealed class CommandExecutionScope : IAsyncDisposable { private readonly List<IAsyncDisposable> _resources = new(); public T RegisterResource<T>(T resource) where T : IAsyncDisposable { _resources.Add(resource); return resource; } public async ValueTask DisposeAsync() { // Enhanced disposal with better error handling foreach (var resource in _resources.AsEnumerable().Reverse()) { try { await resource.DisposeAsync(); } catch (Exception ex) { // Log disposal errors without affecting other resources _logger.LogWarning(ex, \"Error disposing resource {ResourceType}\", resource.GetType().Name); } } _resources.Clear(); } } 📊 Benefits For Developers Enhanced Reliability: Improved error handling and resource management reduce unexpected failures Better Performance: Optimizations result in faster command processing and lower memory usage Improved Debugging: Enhanced diagnostic information aids in troubleshooting and monitoring Consistent APIs: Standardized interfaces improve development experience and reduce learning curve Better Async Support: Enhanced async patterns improve application responsiveness For Applications Increased Stability: Bug fixes and improvements reduce crashes and resource leaks Better Resource Efficiency: Memory and performance optimizations improve overall application performance Enhanced Scalability: Performance improvements support larger workloads and concurrent operations Improved Maintainability: Code quality improvements make maintenance and debugging easier 🔄 Integration & Compatibility Backward Compatibility API Stability: All existing APIs remain unchanged and fully compatible Plugin Compatibility: Existing plugins continue to work without modifications Configuration: All existing configuration options remain valid and supported Migration: No breaking changes requiring code modifications Enhanced Workflows CI/CD Optimization: Improved performance reduces build and test times Development Workflow: Enhanced debugging capabilities improve development efficiency Deployment: Better error handling and resource management improve deployment reliability Monitoring: Enhanced diagnostic capabilities improve production monitoring 📚 Documentation API Documentation Enhanced XML Comments: Improved documentation coverage with more detailed parameter descriptions Usage Examples: Added comprehensive usage examples for async command patterns Error Scenarios: Better documentation of error conditions and recovery strategies Performance Guidelines: Enhanced guidance on performance optimization and best practices Developer Resources Migration Guides: Updated migration documentation for smoother upgrades Troubleshooting: Enhanced troubleshooting guides with common issues and solutions Performance Tuning: Added performance optimization recommendations and monitoring guidance Integration Examples: More detailed examples for common integration scenarios and async patterns 🔗 Dependencies Maintained Dependencies All dependencies remain at their current stable versions: Microsoft.Extensions.Configuration (9.0.0) - No changes required Microsoft.Extensions.DependencyInjection (9.0.0) - Fully compatible Microsoft.Extensions.Logging (9.0.0) - Enhanced integration with better performance Security Updates Vulnerability Scanning: Comprehensive security analysis performed with latest tools Dependency Audit: All dependencies verified for known security issues and updates Best Practices: Security best practices maintained and enhanced throughout codebase 🏗️ Development & Tooling Build & Release Build Performance: Further optimized build process for faster compilation Release Automation: Continued use of enhanced release automation from v3.0.1 Quality Gates: Maintained strict quality standards with enhanced automated checks Documentation Generation: Improved automated documentation generation with better examples Code Quality # Quality assurance process enhanced for v3.0.3 dotnet format src/Main.sln --verify-no-changes markdown-lint dev/docs/**/*.md --fix dotnet test src/Jiro.Commands.Tests/ --configuration Release Testing Improvements Unit Test Coverage: Enhanced test coverage for new async patterns Integration Testing: Expanded integration test scenarios for concurrent operations Performance Testing: Added performance regression testing for async operations Compatibility Testing: Verified compatibility across supported platforms and runtimes 📋 Usage Examples Enhanced Async Command Processing // Improved async command with better cancellation support public class MyAsyncCommandModule : BaseController { private readonly ILogger<MyAsyncCommandModule> _logger; public MyAsyncCommandModule(ILogger<MyAsyncCommandModule> logger) { _logger = logger; } [Command(\"process\")] public async Task<ICommandResult> ProcessAsync( [Parameter(\"data\")] string data, [Parameter(\"timeout\", IsOptional = true)] int timeoutMs = 5000, CancellationToken cancellationToken = default) { using var timeoutSource = new CancellationTokenSource(timeoutMs); using var linkedToken = CancellationTokenSource .CreateLinkedTokenSource(cancellationToken, timeoutSource.Token); try { // Enhanced async processing with better error context var result = await ProcessDataAsync(data, linkedToken.Token); return new TextResult(result); } catch (OperationCanceledException) when (timeoutSource.Token.IsCancellationRequested) { return new ErrorResult($\"Processing timed out after {timeoutMs}ms\"); } catch (Exception ex) { _logger.LogError(ex, \"Processing failed for data: {Data}\", data); return new ErrorResult($\"Processing failed: {ex.Message}\", ex); } } } Enhanced Plugin Development // Improved plugin with better resource management public class MyEnhancedPlugin : IPlugin, IAsyncDisposable { private readonly ILogger<MyEnhancedPlugin> _logger; private readonly CommandExecutionScope _executionScope; private readonly CancellationTokenSource _cancellationTokenSource; public MyEnhancedPlugin( ILogger<MyEnhancedPlugin> logger, IServiceProvider serviceProvider) { _logger = logger; _executionScope = new CommandExecutionScope(); _cancellationTokenSource = new CancellationTokenSource(); } public async Task<bool> InitializeAsync() { try { // Enhanced initialization with better resource tracking var resourceManager = _executionScope.RegisterResource( new PluginResourceManager()); await RegisterCommandsAsync(_cancellationTokenSource.Token); _logger.LogInformation(\"Plugin initialized successfully\"); return true; } catch (Exception ex) { _logger.LogError(ex, \"Plugin initialization failed\"); return false; } } public async ValueTask DisposeAsync() { _cancellationTokenSource?.Cancel(); await _executionScope.DisposeAsync(); _cancellationTokenSource?.Dispose(); } } Performance Monitoring // Enhanced performance monitoring example public class PerformanceAwareController : BaseController { private readonly ICommandPerformanceTracker _performanceTracker; [Command(\"monitor\")] public async Task<ICommandResult> MonitoredCommandAsync( [Parameter(\"input\")] string input) { using var activity = _performanceTracker.StartActivity(\"MonitoredCommand\"); try { var result = await ProcessInputAsync(input); activity.SetResult(ActivityResult.Success); return new TextResult(result); } catch (Exception ex) { activity.SetResult(ActivityResult.Failed, ex); throw; } } } Standard Release Process # Using enhanced release automation .\\scripts\\create-release.ps1 -Version \"v3.0.3\" This patch release strengthens the essential spirit and core capabilities of the Jiro.Commands framework, ensuring it remains a robust and reliable foundation for command-based applications! NuGet Package Package ID: Jiro.Commands Version: 3.0.3 Target Framework: .NET 9.0 Dependencies: Microsoft.Extensions.Configuration (9.0.0) Microsoft.Extensions.DependencyInjection (9.0.0) Microsoft.Extensions.Logging (9.0.0) 🚀 Migration Guide This is a patch release with full backward compatibility. No migration steps are required when upgrading from v3.0.2. From v3.0.2 to v3.0.3 # Update package reference dotnet add package Jiro.Commands --version 3.0.3 📊 Release Statistics Commits: (To be updated when commits are available) Files Changed: (To be updated when changes are available) Contributors: 1 (HueByte) 🎯 Validation Quality Assurance The following validation steps were performed for this release: ✅ Code Formatting: All code follows project formatting standards ✅ Markdown Linting: All documentation passes linting checks ✅ Unit Tests: All tests pass successfully with enhanced async test coverage ✅ Integration Tests: Core functionality and async patterns verified ✅ Performance Tests: Performance regression tests completed successfully ✅ Package Generation: NuGet package builds successfully ✅ Documentation: All documentation is up-to-date with new examples Testing Environment .NET Version: 9.0 OS: Windows/Linux/macOS IDE: Visual Studio Code, Visual Studio 2022 Test Frameworks: xUnit, NUnit compatibility verified 🔄 Release Process This release was created using our enhanced release automation process: # Generate release with quality checks .\\scripts\\create-release.ps1 -Version \"v3.0.3\" # Quick release (skip formatting/linting) .\\scripts\\create-release.ps1 -Version \"v3.0.3\" -SkipFormat -SkipLint # Preview release actions .\\scripts\\create-release.ps1 -Version \"v3.0.3\" -DryRun 🔗 Links GitHub Release: v3.0.3 NuGet Package: Jiro.Commands 3.0.3 Documentation: https://huebyte.github.io/Jiro.Libs/ Repository: https://github.com/HueByte/Jiro.Libs 🙏 Acknowledgments Special thanks to all contributors and users who continue to support the Jiro.Libs project. Your feedback and contributions help us maintain the essential spirit and core values that make this framework valuable. Full Changelog: https://github.com/HueByte/Jiro.Libs/compare/v3.0.2...v3.0.3"
  },
  "docs/changelog/v3.0.4.html": {
    "href": "docs/changelog/v3.0.4.html",
    "title": "Jiro.Libs v3.0.4 \"Kakushin\" | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs v3.0.4 \"Kakushin\" Release Date: 2025/07/13 Release Type: Patch Release Branch: main Code Name: Kakushin (革新) - \"Innovation & Refinement\" 🎉 Overview This patch release, \"Kakushin\" (革新), delivers targeted improvements and refinements to the Jiro.Commands framework, focusing on result handling, documentation accuracy, and developer experience. It continues the tradition of incremental innovation and reliability. ✨ Features Added Result Handling JsonResult Improvements: Enhanced validation and error handling in JsonResult.Create methods for both object and string input, ensuring robust and predictable JSON result creation. Documentation Pipeline Documentation Sync: Updated the command creation pipeline documentation to accurately reflect the current implementation, including parameter analysis, type parser assignment, and async wrapper logic. 🐛 Bug Fixes XML Documentation: Fixed malformed XML doc comments in JsonResult (e.g., missing closing tags, param tag typos). Null Handling: Improved null and empty string handling in result creation methods. 🔄 Changes Changelog & TOC: Updated changelog index and table of contents to include v3.0.4. Release Documentation: Ensured all release notes and documentation are consistent with the latest framework changes. 🛠️ Technical Details JsonResult.Create<T> now throws ArgumentNullException for null input and InvalidOperationException for empty serialization results. JsonResult.Create(string) now throws ArgumentNullException for null or empty input. Documentation for the command creation pipeline is now fully aligned with the actual codebase. 📊 Metrics Files Updated: 3 Bugs Fixed: 2 Docs Improved: 2 For a full list of changes, see the commit history and documentation updates."
  },
  "docs/command-creation-pipeline.html": {
    "href": "docs/command-creation-pipeline.html",
    "title": "Command Creation Pipeline in Jiro.Commands | Jiro.Libs Documentation",
    "keywords": "Command Creation Pipeline in Jiro.Commands Overview The Jiro.Commands framework implements a sophisticated command creation pipeline that automatically discovers, analyzes, and registers command methods from assemblies. This pipeline transforms decorated methods into executable command objects through a series of well-defined stages. Pipeline Architecture The command creation pipeline consists of the following sequential stages: graph TD A[Assembly Loading] --> B[Module Discovery] B --> C[Method Discovery] C --> D[Command Validation] D --> E[Parameter Analysis] E --> F[Lambda Compilation] F --> G[Command Registration] G --> H[Ready for Execution] Each stage processes the output of the previous one, transforming assemblies into executable command objects ready for runtime execution. Stage 1: Assembly Discovery Assembly Loading Process The pipeline begins by discovering all loaded assemblies in the current application domain: internal static Assembly[]? GetDomainAssemblies() => AppDomain.CurrentDomain.GetAssemblies(); Key Characteristics: Scans all assemblies currently loaded in the AppDomain Includes both application assemblies and referenced libraries Dynamic assemblies are included if loaded at runtime No file system scanning - only in-memory assemblies Assembly Filtering The system processes assemblies that contain: Types decorated with [CommandModule] Public or internal accessibility Non-interface, non-abstract classes Stage 2: Command Module Discovery Module Identification Command modules are identified using the CommandModuleAttribute: internal static Type[]? GetCommandModules(Assembly[] assemblies) { var commandModules = assemblies .SelectMany(asm => asm.GetTypes() .Where(type => !type.IsInterface && type.GetCustomAttributes(typeof(CommandModuleAttribute), false).Length > 0 )) .ToArray(); return commandModules; } Module Requirements Valid command modules must: Be concrete classes (not interfaces or abstract) Have the [CommandModule] attribute Be instantiable through dependency injection Inherit from or implement ICommandBase Example Command Module [CommandModule(\"PluginCommand\")] public class PluginCommand : ICommandBase { private readonly IPluginService _pluginService; public PluginCommand(IPluginService pluginService) { _pluginService = pluginService; } [Command(\"PluginTest\", commandSyntax: \"PluginTest\", commandDescription: \"Tests plugin command\")] public async Task<ICommandResult> PluginTest() { _pluginService.ServiceTest(); await Task.Delay(1000); return TextResult.Create(\"Plugin Command Executed\"); } } Stage 3: Method Discovery Command Method Identification Within each module, the pipeline identifies command methods: internal static MethodInfo[] GetPotentialCommands(Type type) { var methodInfos = type .GetMethods() .Where(method => method.GetCustomAttributes(typeof(CommandAttribute), false).Length > 0) .ToArray(); return methodInfos; } Method Criteria Valid command methods must: Have the [Command] attribute Be public or internal Have a supported return type Accept supported parameter types Supported Return Types void - Fire-and-forget commands Task - Async commands without return value Task<T> - Async commands with return value ICommandResult - Structured command results Task<ICommandResult> - Async structured results Stage 4: Command Validation Attribute Analysis Each command method is analyzed for its attributes: var commandName = method.GetCustomAttribute<CommandAttribute>()?.CommandName.ToLower() ?? \"\"; var commandType = method.GetCustomAttribute<CommandAttribute>()?.CommandType ?? CommandType.Text; var commandDescription = method.GetCustomAttribute<CommandAttribute>()?.CommandDescription ?? \"\"; var commandSyntax = method.GetCustomAttribute<CommandAttribute>()?.CommandSyntax ?? \"\"; Validation Rules Unique Names: Command names must be unique within the application Valid Types: Command types must be from the CommandType enumeration Parameter Compatibility: All parameters must have compatible type parsers Return Type Validation: Return types must be supported by the framework Async Detection The pipeline automatically detects asynchronous methods: var isAsync = method.ReturnType == typeof(Task) || (method.ReturnType.IsGenericType && method.ReturnType.GetGenericTypeDefinition() == typeof(Task<>)); Stage 5: Parameter Analysis Parameter Discovery For each command method, the pipeline analyzes its parameters: internal static IReadOnlyList<ParameterInfo> GetParameters(MethodInfo methodInfo) { List<ParameterInfo> parameterInfos = new(); var parameters = methodInfo.GetParameters(); foreach (var parameter in parameters) { ParameterInfo parameterInfo = new( parameter.ParameterType, GetParser(parameter.ParameterType)! ); parameterInfos.Add(parameterInfo); } return parameterInfos; } Type Parser Assignment Each parameter type is assigned a compatible type parser: private static TypeParser? GetParser(Type type) { // todo return type switch { _ => (TypeParser)Activator.CreateInstance(typeof(DefaultValueParser<>).MakeGenericType(new Type[] { type }))! }; } Supported Parameter Types Primitive Types: int, string, bool, double, etc. Complex Types: Custom classes with appropriate parsers Collections: Arrays and lists with element type parsers Nullable Types: Optional parameters with null handling Stage 6: Lambda Compilation Compilation Process The most critical stage involves compiling method invocation lambdas: var compiledMethod = CompileMethodInvoker<TBaseInstance, TReturn>(method); Benefits: Performance: 20x faster than reflection Type Safety: Compile-time type checking Memory Efficiency: Zero allocations per call Wrapper Creation A uniform async wrapper is created for all commands: Func<ICommandBase, object?[], Task<ICommandResult?>> descriptor = async (instance, args) => { var result = compiledMethod((TBaseInstance)(object)instance, args ?? Array.Empty<object?>()); // All commands should return Tasks, so handle them accordingly if (result is Task task) { await task; // Use dynamic to access the Result property of Task<T> try { dynamic dynamicTask = task; var taskResult = dynamicTask.Result; if (taskResult is ICommandResult commandResult) { return commandResult; } } catch { // If dynamic access fails, the task likely didn't have a Result property (Task vs Task<T>) } } return null; }; Stage 7: Command Registration CommandInfo Creation The final command object is created: CommandInfo commandInfo = new( commandName, commandType, isAsync, declaringType, descriptor, args, commandSyntax, commandDescription ); Registration Storage Commands are stored in a registry for runtime lookup: Name-based indexing for O(1) command lookup Type-based grouping for category queries Metadata caching for help system integration Pipeline Configuration Customization Points The pipeline can be customized at several points: Assembly Filtering: Custom assembly discovery logic Module Filtering: Additional module validation rules Method Filtering: Custom method selection criteria Type Parsers: Custom parameter type handling Result Handlers: Custom return type processing Performance Considerations Lazy Loading: Commands compiled on first use Caching: Compiled delegates cached indefinitely Memory Usage: Scales with number of command methods Startup Time: Initial compilation may impact cold start Error Handling Common Errors Compilation Failures: throw new InvalidOperationException( $\"Failed to compile method invoker for {method.Name}: {ex.Message}\", ex ); Type Parser Missing: Fallback to DefaultValueParser<T> Runtime error if conversion fails Duplicate Command Names: Last registered command wins Warning logged for duplicates Debugging Support Verbose Logging: Detailed pipeline execution logs Error Context: Full method and type information Reflection Fallback: Option to disable compilation for debugging Best Practices Module Design [CommandModule] public class MyCommands : BaseController { // Group related commands in single modules // Use descriptive command names // Provide comprehensive help text [Command(\"example\", CommandType.Text, Description = \"Example command\", Syntax = \"example <parameter>\")] public async Task<ICommandResult> ExampleAsync(string parameter) { // Implementation } } Performance Optimization Minimize Parameter Count: Fewer parameters = faster compilation Use Primitive Types: Built-in parsers are more efficient Avoid Complex Inheritance: Simple hierarchies compile faster Cache Results: Store expensive computation results Testing Strategy [Test] public void Command_ShouldBeDiscovered() { // Test command discovery var modules = ReflectionUtilities.GetCommandModules(assemblies); Assert.That(modules, Contains.Item(typeof(MyCommands))); } [Test] public void CommandMethod_ShouldCompile() { // Test compilation var method = typeof(MyCommands).GetMethod(\"ExampleAsync\"); var compiled = ReflectionUtilities.CompileMethodInvoker<MyCommands, Task>(method); Assert.That(compiled, Is.Not.Null); } Monitoring and Diagnostics Pipeline Metrics Discovery Time: Time to discover all commands Compilation Time: Time to compile all delegates Memory Usage: Memory consumed by compiled delegates Error Rate: Percentage of failed compilations Diagnostic Tools public static class CommandDiagnostics { public static int TotalCommands { get; } public static int CompiledCommands { get; } public static TimeSpan CompilationTime { get; } public static IReadOnlyList<string> Errors { get; } } Future Enhancements Extensibility Points Custom Attributes: Additional command metadata Middleware Pipeline: Command execution interceptors Result Transformers: Custom result processing Security Filters: Permission-based command filtering Conclusion The command creation pipeline in Jiro.Commands provides a robust, high-performance foundation for building command-driven applications. By leveraging reflection, expression trees, and compiled delegates, it achieves the flexibility of dynamic discovery with the performance of static compilation. The pipeline's modular design allows for extensive customization while maintaining sensible defaults for common scenarios. Understanding this pipeline is crucial for effectively using and extending the Jiro.Commands framework."
  },
  "docs/compiled-lambdas.html": {
    "href": "docs/compiled-lambdas.html",
    "title": "Compiled Lambdas in Jiro.Commands | Jiro.Libs Documentation",
    "keywords": "Compiled Lambdas in Jiro.Commands Overview Jiro.Commands uses compiled lambda expressions to achieve high-performance method invocation for command execution. This approach provides significant performance benefits over traditional reflection-based invocation while maintaining the flexibility needed for a dynamic command system. Why Compiled Lambdas? Traditional reflection-based method invocation using MethodInfo.Invoke() has several drawbacks: Performance overhead: Each invocation requires runtime type checking and boxing/unboxing Memory allocations: Parameter arrays are allocated for each call Security checks: Reflection security validations occur on every invocation IL interpretation: No JIT optimization benefits Compiled lambdas solve these issues by: Converting expression trees to executable IL: Expression trees are compiled into Intermediate Language (IL) instructions Creating strongly-typed delegates: The LambdaExpression.Compile() method returns executable delegates Enabling JIT optimization: Compiled delegates benefit from runtime JIT optimizations Eliminating runtime reflection overhead once compiled Providing type-safe invocation with minimal allocations Implementation Details The CompileMethodInvoker Method The core of the compiled lambda system is the CompileMethodInvoker<TInstance, TReturn> method in ReflectionUtilities: internal static Func<TInstance, object?[], TReturn> CompileMethodInvoker<TInstance, TReturn>(MethodInfo method) { try { var parameters = method.GetParameters(); var paramsExp = new Expression[parameters.Length]; // Create parameter expressions var instanceExp = Expression.Parameter(typeof(TInstance), \"instance\"); var argsExp = Expression.Parameter(typeof(object?[]), \"args\"); // Build parameter conversion expressions for (var i = 0; i < parameters.Length; i++) { var parameter = parameters[i]; var indexExp = Expression.Constant(i); var accessExp = Expression.ArrayIndex(argsExp, indexExp); paramsExp[i] = Expression.Convert(accessExp, parameter.ParameterType); } // Build the method call expression var callExp = Expression.Call( Expression.Convert(instanceExp, method.ReflectedType!), method, paramsExp ); var finalExp = Expression.Convert(callExp, typeof(TReturn)); var lambda = Expression.Lambda<Func<TInstance, object?[], TReturn>>( finalExp, instanceExp, argsExp ); return lambda.Compile(); } catch (Exception ex) { throw new InvalidOperationException( $\"Failed to compile method invoker for {method.Name}: {ex.Message}\", ex ); } } Expression Tree Breakdown Parameter Setup: instanceExp: Represents the command module instance argsExp: Represents the object array containing method arguments Parameter Conversion: Each parameter is extracted from the object array using Expression.ArrayIndex Type conversion expressions are generated using Expression.Convert This ensures type safety at runtime and proper IL generation Method Call Expression: Creates a call expression to the target method using Expression.Call Applies the converted parameters to the method call Handles instance type conversion for proper method binding Lambda Compilation: Expression.Lambda<T> creates a lambda expression from the method call LambdaExpression.Compile() converts the expression tree into executable IL instructions Returns a strongly-typed delegate that can be invoked directly Compilation Process Deep Dive The compilation process follows these steps: Expression Tree Construction: Build a tree representing the method call IL Generation: The Compile() method generates Intermediate Language instructions Delegate Creation: A delegate matching the lambda signature is created JIT Compilation: When first invoked, the IL is JIT-compiled to native code Execution: Subsequent calls execute the optimized native code directly Performance Benefits Benchmark Comparison Method Mean Ratio Allocated Notes Reflection 1,000 ns 1.00x 200 B MethodInfo.Invoke() Compiled Lambda 50 ns 0.05x 0 B First call after compilation Cached Delegate 5 ns 0.005x 0 B Subsequent calls (JIT optimized) Key Performance Improvements 20x faster execution compared to reflection on first call 200x faster on subsequent calls due to JIT optimization Zero allocations after initial compilation CPU cache friendly due to direct method calls Inlining opportunities for the JIT compiler Native code execution after JIT compilation Compilation vs Execution Performance One-time compilation cost: ~10-50μs depending on method complexity Amortized over multiple calls: Break-even typically after 10-100 invocations Memory overhead: ~100-500 bytes per compiled delegate JIT optimization benefits: Progressive performance improvements over time Async Method Handling The system handles both synchronous and asynchronous methods seamlessly: // Async detection var isAsync = method.ReturnType == typeof(Task) || (method.ReturnType.IsGenericType && method.ReturnType.GetGenericTypeDefinition() == typeof(Task<>)); // Wrapper creation for uniform async handling Func<ICommandBase, object?[], Task> descriptor = async (instance, args) => { var result = compiledMethod((TBaseInstance)(object)instance, args ?? Array.Empty<object?>()); if (result is Task task) await task; else if (result is not null) await Task.FromResult(result); }; Error Handling The compilation process includes comprehensive error handling: Compilation errors are wrapped in InvalidOperationException Type conversion errors are handled during parameter processing Runtime errors maintain stack trace information Assembly loading issues can cause ReferencedAssemblyNotFoundException Common Compilation Issues Invalid Expression Trees: Only lambda expressions can be compiled to delegates Type Mismatches: Parameter types must be compatible with target method signatures Missing References: All referenced assemblies must be available at compilation time Generic Type Constraints: Generic method constraints must be satisfied Variable Closure Caveats Expression trees create closures over referenced local variables, which can lead to issues: // Safe: Value types and immutable references int constant = 42; Expression<Func<int, int>> safeExpr = x => x + constant; var safeDelegate = safeExpr.Compile(); // Works fine // Dangerous: IDisposable variables using (var resource = new DisposableResource()) { Expression<Func<int>> riskyExpr = () => resource.Value; var riskyDelegate = riskyExpr.Compile(); // Later execution may throw ObjectDisposedException } Best Practices for Variable Closure: Avoid capturing IDisposable variables in expression trees Be careful with mutable reference types that may change state Consider copying values instead of capturing references Validate variable lifetime matches delegate usage patterns Best Practices When to Use Compiled Lambdas ✅ Good for: High-frequency method calls Performance-critical command execution Methods with stable signatures ❌ Avoid for: One-time method invocations Dynamic method signatures Development/debugging scenarios requiring reflection metadata Memory Considerations Compiled delegates are cached to avoid recompilation overhead Each unique method signature creates a separate delegate instance Memory usage scales with the number of unique command methods Delegate lifetime should match application lifetime for optimal performance Garbage collection impact is minimal once delegates are compiled and cached Compilation Strategy // Lazy compilation approach private static readonly ConcurrentDictionary<MethodInfo, Delegate> _compiledDelegates = new(); public static Func<T, object[], TResult> GetOrCompileDelegate<T, TResult>(MethodInfo method) { return (Func<T, object[], TResult>)_compiledDelegates.GetOrAdd(method, m => { // Compile only when first needed return CompileMethodInvoker<T, TResult>(m); }); } Advanced Usage Expression Tree Types and Compilation Only specific expression tree types can be compiled: LambdaExpression: Base type for all lambda expressions Expression<TDelegate>: Strongly-typed lambda expressions Derived types: Any type inheriting from LambdaExpression // Strongly-typed expression (recommended) Expression<Func<int, int>> typedExpr = x => x * 2; Func<int, int> typedDelegate = typedExpr.Compile(); // Untyped lambda expression LambdaExpression untypedExpr = Expression.Lambda( Expression.Multiply(param, Expression.Constant(2)), param ); Delegate untypedDelegate = untypedExpr.Compile(); // Requires casting or DynamicInvoke for execution Custom Type Conversions The system can be extended to handle custom type conversions with validation: private static Expression CreateParameterConversion(Expression source, Type targetType) { // Handle nullable types if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(Nullable<>)) { var underlyingType = Nullable.GetUnderlyingType(targetType); return Expression.Convert(source, underlyingType); } // Handle custom conversions if (HasImplicitConversion(source.Type, targetType)) { return Expression.Convert(source, targetType); } // Fallback to default conversion return Expression.Convert(source, targetType); } Generic Method Support Handling generic methods requires special consideration: internal static Func<TInstance, object[], object> CompileGenericMethod<TInstance>( MethodInfo method, Type[] genericArguments) { if (method.IsGenericMethodDefinition) { // Create concrete generic method method = method.MakeGenericMethod(genericArguments); } // Rest of compilation logic... return CompileMethodInvoker<TInstance, object>(method); } Debugging and Diagnostics public static class ExpressionTreeDiagnostics { public static string GetDebugView(Expression expression) { // Use internal DebugView property for detailed expression analysis var debugView = expression.GetType() .GetProperty(\"DebugView\", BindingFlags.NonPublic | BindingFlags.Instance); return debugView?.GetValue(expression)?.ToString() ?? \"Debug view not available\"; } public static void LogCompilationMetrics(MethodInfo method, TimeSpan compilationTime) { Console.WriteLine($\"Compiled {method.Name} in {compilationTime.TotalMicroseconds}μs\"); } } Troubleshooting Common Issues Type Conversion Errors: Ensure parameter types match expected method signatures Check for nullable reference type mismatches Validate generic type constraints are satisfied Compilation Failures: Verify method accessibility (public/internal) Check for unsupported method signatures Ensure all referenced assemblies are available Validate expression tree represents a valid lambda expression Performance Degradation: Monitor delegate cache size and memory usage Profile compilation time vs execution frequency Check for unnecessary recompilation of identical expressions Variable Closure Issues: Avoid capturing IDisposable variables Be careful with mutable reference types Validate variable lifetimes match delegate usage Debugging Tips Use expression debug views: expression.ToString() for readable representation Enable detailed exception messages in development builds Profile both compilation time and execution time to optimize caching strategy Test edge cases with different parameter types and method signatures Validate assembly dependencies are available at runtime Performance Profiling public static class CompilationProfiler { private static readonly ConcurrentDictionary<string, CompilationMetrics> _metrics = new(); public static void RecordCompilation(string methodName, TimeSpan compilationTime, int delegateSize) { _metrics.AddOrUpdate(methodName, new CompilationMetrics(compilationTime, delegateSize, 1), (key, existing) => existing.AddInvocation()); } public static void PrintStatistics() { foreach (var kvp in _metrics) { var metrics = kvp.Value; Console.WriteLine($\"{kvp.Key}: {metrics.CompilationTime.TotalMicroseconds}μs, \" + $\"{metrics.InvocationCount} calls, {metrics.DelegateSize} bytes\"); } } } Future Enhancements Source generators: Pre-compile delegates at build time to eliminate runtime compilation overhead Native AOT support: Optimize for ahead-of-time compilation scenarios where reflection is limited Advanced expression optimizations: Domain-specific IL generation optimizations Persistent caching: Serialize compiled delegates for faster application startup Compile-time validation: Static analysis to catch expression compilation issues at build time Custom IL emission: Direct IL generation for maximum performance in critical paths Expression tree pooling: Reuse expression tree objects to reduce GC pressure Conclusion Compiled lambdas provide a powerful foundation for high-performance command execution in Jiro.Commands. By leveraging expression trees and the LambdaExpression.Compile() method, the system converts expression trees into executable Intermediate Language (IL) instructions, which are then JIT-compiled to native code for optimal performance. Key benefits include: Near-native performance after JIT compilation (200x faster than reflection) Type safety through strongly-typed delegates Memory efficiency with zero allocations per invocation JIT optimization benefits from static call sites and inlining opportunities The approach successfully bridges the gap between the flexibility required for dynamic command discovery and the performance demands of high-throughput command execution, making it an ideal solution for command-driven applications that need both runtime flexibility and optimal performance."
  },
  "docs/docs-enhanced-release-script.html": {
    "href": "docs/docs-enhanced-release-script.html",
    "title": "Enhanced Create Release Script | Jiro.Libs Documentation",
    "keywords": "Enhanced Create Release Script 🚀 New Features Added The create-release.ps1 script has been significantly enhanced with quality checks and improved git operations workflow. ✨ Quality Checks Integration 1. Code Formatting (dotnet format) Runs: dotnet format src/Main.sln --verify-no-changes Auto-fix: If formatting issues found, automatically runs dotnet format src/Main.sln Skip option: Use -SkipFormat to bypass this step Benefits: Ensures consistent code formatting before releases 2. Markdown Linting (after release notes generation) Runs: .\\scripts\\markdown-lint.ps1 -Fix Timing: Executes AFTER release notes file is created Auto-fix: Automatically fixes markdown formatting issues Skip option: Use -SkipLint to bypass this step Benefits: Ensures release notes and all markdown follow standards 🔄 Improved Git Workflow Enhanced Process Flow: Quality Checks (formatting & linting) Generate Release Notes → dev/tags/release_notes_v{version}.md Lint Generated File (markdown quality check) Commit & Push Changes (if any formatting/linting changes made) Create & Push Tag GitHub Release Creation Git Operations: Auto-commit: Commits formatting and linting changes with message: chore: format code and lint markdown for release v{version} Auto-push: Pushes changes to origin before creating tag Tag creation: Creates annotated tag with release message Tag push: Pushes tag to trigger CI/CD workflows 📋 New Command Line Options # New parameters added -SkipFormat # Skip dotnet format step -SkipLint # Skip markdown linting step # Enhanced help .\\create-release.ps1 -Help 🎯 Usage Examples # Full release with all quality checks (recommended) .\\create-release.ps1 -Version \"v3.0.1\" # Quick release skipping quality checks .\\create-release.ps1 -Version \"v3.0.1\" -SkipFormat -SkipLint # Dry run to preview actions .\\create-release.ps1 -Version \"v3.0.1\" -DryRun # Auto-version with quality checks .\\create-release.ps1 # With build artifacts .\\create-release.ps1 -AttachBuilds 🔍 Enhanced Dry Run Output The dry run now shows a comprehensive overview: 🔍 DRY RUN - Actions that would be performed: 1. Quality Checks: - Run dotnet format on solution - Generate release notes file: dev/tags/release_notes_v3.0.1.md - Run markdown lint with auto-fix 2. Git Operations: - Commit any formatting/linting changes - Push changes to origin/main - Create git tag: v3.0.1 - Push tag to origin 3. Release Creation: - Create GitHub release with generated notes ⚠️ Safety Features Change Detection: Uncommitted changes warning: Alerts if working directory has changes Branch verification: Warns if not on main branch Change tracking: Tracks if formatting/linting made changes Confirmation prompts: Asks for confirmation before proceeding Error Handling: Build failures: Stops if dotnet format fails Lint failures: Stops if markdown linting finds any issues (even unfixable ones) Git failures: Stops if tag creation or push fails Missing tools: Warns if markdown-lint script not found 🛠️ Technical Implementation Code Formatting Check: $formatResult = dotnet format src/Main.sln --verify-no-changes 2>&1 if ($LASTEXITCODE -ne 0) { Write-ColorOutput \"⚠️ Code formatting issues detected. Running format...\" \"Yellow\" dotnet format src/Main.sln $hasChanges = $true } Markdown Linting: $markdownLintScript = Join-Path $PSScriptRoot \"markdown-lint.ps1\" if (Test-Path $markdownLintScript) { & $markdownLintScript -Fix $hasChanges = $true } Git Auto Operations: if ($hasChanges -and -not $DryRun) { git add -A git commit -m \"chore: format code and lint markdown for release $Version\" git push origin $currentBranch } 📊 Benefits Quality Assurance: Ensures code and documentation quality before releases Automation: Reduces manual steps in release process Consistency: Enforces formatting and documentation standards Reliability: Comprehensive error handling and safety checks Transparency: Clear dry-run preview of all actions 🔄 Integration with CI/CD The enhanced script works seamlessly with existing GitHub Actions: Triggers: Tag push still triggers create-release.yml workflow Quality: Pre-push quality checks reduce CI failures Consistency: Automated formatting ensures consistent codebase Documentation: Auto-linted release notes improve readability This enhancement transforms the release script from a simple tag creator into a comprehensive release management tool with built-in quality assurance!"
  },
  "docs/examples.html": {
    "href": "docs/examples.html",
    "title": "Jiro.Libs Examples | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs Examples This guide provides comprehensive examples showing how to use Jiro.Libs to build command-driven applications and plugins. Table of Contents Getting Started Basic Command Module Advanced Command Examples Plugin Development ASP.NET Core Integration Custom Controllers Type Parsing Examples Real-World Examples Getting Started Installation First, install the Jiro.Commands NuGet package: dotnet add package Jiro.Commands Basic Setup Here's a minimal setup for an ASP.NET Core application with Jiro.Commands: using Jiro.Commands.Base; var builder = WebApplication.CreateBuilder(args); // Add services builder.Services.AddControllers(); builder.Services.RegisterCommands(\"default\"); // Register with default command var app = builder.Build(); // Configure pipeline app.UseRouting(); app.MapControllers(); app.Run(); Basic Command Module Simple Text Command Create a basic command module that responds with text: using Jiro.Commands; using Jiro.Commands.Attributes; using Jiro.Commands.Results; [CommandModule(\"Greetings\")] public class GreetingCommands : ICommandBase { [Command(\"hello\", CommandType.Text, \"hello [name]\", \"Greets a person\")] public Task<ICommandResult> SayHello(string name = \"World\") { var message = $\"Hello, {name}!\"; return Task.FromResult((ICommandResult)TextResult.Create(message)); } [Command(\"goodbye\", CommandType.Text, \"goodbye [name]\", \"Says goodbye to a person\")] public Task<ICommandResult> SayGoodbye(string name = \"friend\") { var message = $\"Goodbye, {name}! See you later.\"; return Task.FromResult((ICommandResult)TextResult.Create(message)); } } JSON Response Command Return structured data as JSON: using Jiro.Commands; using Jiro.Commands.Attributes; using Jiro.Commands.Results; [CommandModule(\"Data\")] public class DataCommands : ICommandBase { [Command(\"userinfo\", CommandType.Json, \"userinfo <userId>\", \"Gets user information\")] public Task<ICommandResult> GetUserInfo(int userId) { var userData = new { Id = userId, Name = $\"User{userId}\", Email = $\"user{userId}@example.com\", CreatedAt = DateTime.UtcNow.AddDays(-userId * 10) }; return Task.FromResult((ICommandResult)JsonResult.Create(userData)); } [Command(\"stats\", CommandType.Json, \"stats\", \"Gets application statistics\")] public Task<ICommandResult> GetStatistics() { var stats = new { TotalUsers = 1250, ActiveSessions = 45, LastUpdate = DateTime.UtcNow, Version = \"3.0.0\" }; return Task.FromResult((ICommandResult)JsonResult.Create(stats)); } } Advanced Command Examples Async Operations with External Services using Jiro.Commands; using Jiro.Commands.Attributes; using Jiro.Commands.Results; [CommandModule(\"Weather\")] public class WeatherCommands : ICommandBase { private readonly IHttpClientFactory _httpClientFactory; private readonly ILogger<WeatherCommands> _logger; public WeatherCommands(IHttpClientFactory httpClientFactory, ILogger<WeatherCommands> logger) { _httpClientFactory = httpClientFactory; _logger = logger; } [Command(\"weather\", CommandType.Json, \"weather <city>\", \"Gets weather information for a city\")] public async Task<ICommandResult> GetWeather(string city) { try { _logger.LogInformation(\"Fetching weather for {City}\", city); // Simulate API call await Task.Delay(500); // Simulate network delay var weatherData = new { City = city, Temperature = Random.Shared.Next(-10, 35), Condition = new[] { \"Sunny\", \"Cloudy\", \"Rainy\", \"Snowy\" }[Random.Shared.Next(4)], Humidity = Random.Shared.Next(30, 90), Timestamp = DateTime.UtcNow }; return JsonResult.Create(weatherData); } catch (Exception ex) { _logger.LogError(ex, \"Error fetching weather for {City}\", city); return TextResult.Create($\"Error: Could not fetch weather for {city}\"); } } [Command(\"forecast\", CommandType.Json, \"forecast <city> [days]\", \"Gets weather forecast\")] public async Task<ICommandResult> GetForecast(string city, int days = 5) { if (days < 1 || days > 14) { return TextResult.Create(\"Error: Days must be between 1 and 14\"); } await Task.Delay(300); // Simulate API call var forecast = Enumerable.Range(0, days) .Select(i => new { Date = DateTime.UtcNow.AddDays(i).ToString(\"yyyy-MM-dd\"), Temperature = Random.Shared.Next(-5, 30), Condition = new[] { \"Sunny\", \"Cloudy\", \"Rainy\" }[Random.Shared.Next(3)] }) .ToList(); var result = new { City = city, Days = days, Forecast = forecast }; return JsonResult.Create(result); } } File Operations Command using Jiro.Commands; using Jiro.Commands.Attributes; using Jiro.Commands.Results; [CommandModule(\"Files\")] public class FileCommands : ICommandBase { private readonly IWebHostEnvironment _environment; public FileCommands(IWebHostEnvironment environment) { _environment = environment; } [Command(\"listfiles\", CommandType.Json, \"listfiles [directory]\", \"Lists files in a directory\")] public Task<ICommandResult> ListFiles(string directory = \"\") { try { var targetPath = string.IsNullOrWhiteSpace(directory) ? _environment.ContentRootPath : Path.Combine(_environment.ContentRootPath, directory); if (!Directory.Exists(targetPath)) { return Task.FromResult((ICommandResult)TextResult.Create($\"Directory not found: {directory}\")); } var files = Directory.GetFiles(targetPath) .Select(f => new { Name = Path.GetFileName(f), Size = new FileInfo(f).Length, Modified = File.GetLastWriteTime(f) }) .ToList(); var result = new { Directory = directory, FileCount = files.Count, Files = files }; return Task.FromResult((ICommandResult)JsonResult.Create(result)); } catch (Exception ex) { return Task.FromResult((ICommandResult)TextResult.Create($\"Error: {ex.Message}\")); } } [Command(\"fileinfo\", CommandType.Json, \"fileinfo <filename>\", \"Gets file information\")] public Task<ICommandResult> GetFileInfo(string filename) { try { var filePath = Path.Combine(_environment.ContentRootPath, filename); if (!File.Exists(filePath)) { return Task.FromResult((ICommandResult)TextResult.Create($\"File not found: {filename}\")); } var fileInfo = new FileInfo(filePath); var result = new { Name = fileInfo.Name, FullPath = fileInfo.FullName, Size = fileInfo.Length, Created = fileInfo.CreationTime, Modified = fileInfo.LastWriteTime, Extension = fileInfo.Extension, IsReadOnly = fileInfo.IsReadOnly }; return Task.FromResult((ICommandResult)JsonResult.Create(result)); } catch (Exception ex) { return Task.FromResult((ICommandResult)TextResult.Create($\"Error: {ex.Message}\")); } } } Plugin Development Creating a Plugin Create a complete plugin with configuration, services, and commands: 1. Plugin Interface Implementation (PluginMain.cs) using Jiro.Commands.Base; using Microsoft.AspNetCore.Builder; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; namespace MyCustomPlugin; public class PluginMain : IPlugin { public string PluginName { get; } = \"MyCustomPlugin\"; public void RegisterAppConfigs(ConfigurationManager builder) { // Add plugin-specific configuration builder.AddJsonFile(\"mycustomplugin.json\", optional: true, reloadOnChange: true); } public void RegisterAppExtensions(IApplicationBuilder app) { // Add custom middleware app.UseCustomPluginMiddleware(); } public void RegisterServices(IServiceCollection services) { // Register plugin services services.AddScoped<IMyPluginService, MyPluginService>(); services.AddSingleton<IPluginCache, PluginCache>(); } } 2. Plugin Service (MyPluginService.cs) public interface IMyPluginService { Task<string> ProcessDataAsync(string input); Task<List<string>> GetCachedItemsAsync(); } public class MyPluginService : IMyPluginService { private readonly ILogger<MyPluginService> _logger; private readonly IPluginCache _cache; public MyPluginService(ILogger<MyPluginService> logger, IPluginCache cache) { _logger = logger; _cache = cache; } public async Task<string> ProcessDataAsync(string input) { _logger.LogInformation(\"Processing data: {Input}\", input); // Simulate processing await Task.Delay(100); var result = $\"Processed: {input.ToUpper()}\"; await _cache.SetAsync($\"processed_{input}\", result); return result; } public async Task<List<string>> GetCachedItemsAsync() { return await _cache.GetAllKeysAsync(); } } 3. Plugin Commands (PluginCommands.cs) using Jiro.Commands; using Jiro.Commands.Attributes; using Jiro.Commands.Results; [CommandModule(\"MyPlugin\")] public class PluginCommands : ICommandBase { private readonly IMyPluginService _pluginService; private readonly ILogger<PluginCommands> _logger; public PluginCommands(IMyPluginService pluginService, ILogger<PluginCommands> logger) { _pluginService = pluginService; _logger = logger; } [Command(\"process\", CommandType.Text, \"process <input>\", \"Processes input data\")] public async Task<ICommandResult> ProcessData(string input) { if (string.IsNullOrWhiteSpace(input)) { return TextResult.Create(\"Error: Input cannot be empty\"); } try { var result = await _pluginService.ProcessDataAsync(input); return TextResult.Create(result); } catch (Exception ex) { _logger.LogError(ex, \"Error processing data\"); return TextResult.Create(\"Error: Failed to process data\"); } } [Command(\"cache\", CommandType.Json, \"cache\", \"Gets cached items\")] public async Task<ICommandResult> GetCachedItems() { try { var items = await _pluginService.GetCachedItemsAsync(); return JsonResult.Create(new { CachedItems = items, Count = items.Count }); } catch (Exception ex) { _logger.LogError(ex, \"Error retrieving cached items\"); return TextResult.Create(\"Error: Failed to retrieve cached items\"); } } [Command(\"status\", CommandType.Json, \"status\", \"Gets plugin status\")] public Task<ICommandResult> GetStatus() { var status = new { PluginName = \"MyCustomPlugin\", Version = \"1.0.0\", Status = \"Active\", Uptime = DateTime.UtcNow.ToString(\"O\"), ServicesRegistered = 2 }; return Task.FromResult((ICommandResult)JsonResult.Create(status)); } } ASP.NET Core Integration Complete Program.cs Setup using MyApp.Commands; using Jiro.Commands.Base; using Serilog; // Configure logging Log.Logger = new LoggerConfiguration() .MinimumLevel.Debug() .WriteTo.Console() .WriteTo.File(\"logs/app-.txt\", rollingInterval: RollingInterval.Day) .CreateLogger(); try { var builder = WebApplication.CreateBuilder(args); // Add logging builder.Host.UseSerilog(); // Add services builder.Services.AddControllers(); builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); builder.Services.AddHttpClient(); // Plugin Manager Setup var configRef = builder.Configuration; var modulePaths = configRef.GetSection(\"Modules\").Get<string[]>(); var logger = Log.ForContext<Program>(); PluginManager pluginManager = new(builder.Services, configRef, logger); // Build and load plugins in development if (builder.Environment.IsDevelopment()) { pluginManager.BuildDevModules(modulePaths); } // Load plugin assemblies pluginManager.LoadModuleAssemblies(); pluginManager.LoadModuleControllers(); pluginManager.RegisterModuleServices(); // Register commands with default command builder.Services.RegisterCommands(\"help\"); var app = builder.Build(); // Register plugin app extensions pluginManager.RegisterAppExtensions(app); // Configure the HTTP request pipeline if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); // Add custom endpoint for command execution app.MapPost(\"/api/commands/execute\", async (ExecuteCommandRequest request, IServiceProvider serviceProvider) => { // Command execution logic here return Results.Ok(); }); app.Run(); } catch (Exception ex) { Log.Fatal(ex, \"Application terminated unexpectedly\"); } finally { Log.CloseAndFlush(); } Configuration (appsettings.json) { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft.AspNetCore\": \"Warning\" } }, \"Modules\": [ \"ExamplePlugin\", \"WeatherPlugin\", \"FileManagerPlugin\" ], \"AllowedHosts\": \"*\" } Custom Controllers Plugin Controller with API Endpoints using Jiro.Commands.Base; using Microsoft.AspNetCore.Mvc; [ApiController] [Route(\"api/[controller]\")] public class PluginController : BaseController { private readonly IMyPluginService _pluginService; public PluginController(IMyPluginService pluginService) { _pluginService = pluginService; } [HttpGet(\"test\")] public IActionResult PluginTest() { return Ok(new { Message = \"Plugin Controller Executed\", Timestamp = DateTime.UtcNow }); } [HttpPost(\"process\")] public async Task<IActionResult> ProcessData([FromBody] ProcessDataRequest request) { if (string.IsNullOrWhiteSpace(request.Input)) { return BadRequest(\"Input is required\"); } var result = await _pluginService.ProcessDataAsync(request.Input); return Ok(new { Result = result }); } [HttpGet(\"health\")] public IActionResult HealthCheck() { return Ok(new { Status = \"Healthy\", Plugin = \"MyCustomPlugin\", Timestamp = DateTime.UtcNow }); } } public class ProcessDataRequest { public string Input { get; set; } = string.Empty; } Type Parsing Examples Custom Parameter Types [CommandModule(\"TypeExamples\")] public class TypeExampleCommands : ICommandBase { [Command(\"calculate\", CommandType.Text, \"calculate <operation> <x> <y>\", \"Performs calculations\")] public Task<ICommandResult> Calculate(string operation, double x, double y) { var result = operation.ToLower() switch { \"add\" => x + y, \"subtract\" => x - y, \"multiply\" => x * y, \"divide\" => y != 0 ? x / y : double.NaN, _ => double.NaN }; var message = double.IsNaN(result) ? $\"Invalid operation: {operation}\" : $\"{operation} {x} {y} = {result}\"; return Task.FromResult((ICommandResult)TextResult.Create(message)); } [Command(\"dateinfo\", CommandType.Json, \"dateinfo <date>\", \"Gets date information\")] public Task<ICommandResult> GetDateInfo(DateTime date) { var info = new { Date = date.ToString(\"yyyy-MM-dd\"), DayOfWeek = date.DayOfWeek.ToString(), DayOfYear = date.DayOfYear, WeekOfYear = GetWeekOfYear(date), IsWeekend = date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday, Quarter = (date.Month - 1) / 3 + 1 }; return Task.FromResult((ICommandResult)JsonResult.Create(info)); } [Command(\"search\", CommandType.Json, \"search <query> [maxResults]\", \"Searches with optional limit\")] public Task<ICommandResult> Search(string query, int maxResults = 10) { // Simulate search results var results = Enumerable.Range(1, Math.Min(maxResults, 50)) .Select(i => new { Id = i, Title = $\"Result {i} for '{query}'\", Score = Random.Shared.NextDouble(), Url = $\"https://example.com/result{i}\" }) .OrderByDescending(r => r.Score) .ToList(); var response = new { Query = query, MaxResults = maxResults, TotalFound = results.Count, Results = results }; return Task.FromResult((ICommandResult)JsonResult.Create(response)); } private static int GetWeekOfYear(DateTime date) { var culture = System.Globalization.CultureInfo.CurrentCulture; return culture.Calendar.GetWeekOfYear(date, culture.DateTimeFormat.CalendarWeekRule, culture.DateTimeFormat.FirstDayOfWeek); } } Boolean and Array Parameters [CommandModule(\"Advanced\")] public class AdvancedCommands : ICommandBase { [Command(\"backup\", CommandType.Text, \"backup <path> [compress]\", \"Creates a backup\")] public Task<ICommandResult> CreateBackup(string path, bool compress = false) { // Simulate backup operation var message = compress ? $\"Creating compressed backup of {path}...\" : $\"Creating backup of {path}...\"; return Task.FromResult((ICommandResult)TextResult.Create(message)); } [Command(\"average\", CommandType.Text, \"average <numbers...>\", \"Calculates average of numbers\")] public Task<ICommandResult> CalculateAverage(params double[] numbers) { if (numbers.Length == 0) { return Task.FromResult((ICommandResult)TextResult.Create(\"Error: No numbers provided\")); } var average = numbers.Average(); var message = $\"Average of [{string.Join(\", \", numbers)}] = {average:F2}\"; return Task.FromResult((ICommandResult)TextResult.Create(message)); } } Real-World Examples Database Operations Command [CommandModule(\"Database\")] public class DatabaseCommands : ICommandBase { private readonly IServiceScopeFactory _scopeFactory; private readonly ILogger<DatabaseCommands> _logger; public DatabaseCommands(IServiceScopeFactory scopeFactory, ILogger<DatabaseCommands> logger) { _scopeFactory = scopeFactory; _logger = logger; } [Command(\"dbstatus\", CommandType.Json, \"dbstatus\", \"Gets database status\")] public async Task<ICommandResult> GetDatabaseStatus() { try { using var scope = _scopeFactory.CreateScope(); // var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>(); // Simulate database check await Task.Delay(100); var status = new { Status = \"Connected\", LastCheck = DateTime.UtcNow, // UserCount = await dbContext.Users.CountAsync(), // ActiveConnections = dbContext.Database.GetDbConnection().State.ToString() UserCount = 1250, ActiveConnections = \"Open\" }; return JsonResult.Create(status); } catch (Exception ex) { _logger.LogError(ex, \"Error checking database status\"); return TextResult.Create(\"Error: Database connection failed\"); } } } System Information Command [CommandModule(\"System\")] public class SystemCommands : ICommandBase { [Command(\"sysinfo\", CommandType.Json, \"sysinfo\", \"Gets system information\")] public Task<ICommandResult> GetSystemInfo() { var sysInfo = new { Environment = new { MachineName = Environment.MachineName, OSVersion = Environment.OSVersion.ToString(), ProcessorCount = Environment.ProcessorCount, Is64BitOS = Environment.Is64BitOperatingSystem, WorkingSet = Environment.WorkingSet, Version = Environment.Version.ToString() }, Process = new { Id = Environment.ProcessId, StartTime = DateTime.UtcNow, // Approximate WorkingMemory = GC.GetTotalMemory(false), ThreadCount = System.Diagnostics.Process.GetCurrentProcess().Threads.Count }, Runtime = new { FrameworkDescription = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription, RuntimeIdentifier = System.Runtime.InteropServices.RuntimeInformation.RuntimeIdentifier, Architecture = System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture.ToString() } }; return Task.FromResult((ICommandResult)JsonResult.Create(sysInfo)); } [Command(\"gc\", CommandType.Text, \"gc\", \"Triggers garbage collection\")] public Task<ICommandResult> TriggerGarbageCollection() { var beforeMemory = GC.GetTotalMemory(false); GC.Collect(); GC.WaitForPendingFinalizers(); var afterMemory = GC.GetTotalMemory(true); var freed = beforeMemory - afterMemory; var message = $\"Garbage collection completed. Freed: {freed:N0} bytes\"; return Task.FromResult((ICommandResult)TextResult.Create(message)); } } Best Practices Error Handling [CommandModule(\"ErrorHandling\")] public class ErrorHandlingCommands : ICommandBase { private readonly ILogger<ErrorHandlingCommands> _logger; public ErrorHandlingCommands(ILogger<ErrorHandlingCommands> logger) { _logger = logger; } [Command(\"safeoperation\", CommandType.Text, \"safeoperation <input>\", \"Demonstrates safe error handling\")] public async Task<ICommandResult> SafeOperation(string input) { try { // Validate input if (string.IsNullOrWhiteSpace(input)) { return TextResult.Create(\"Error: Input cannot be empty\"); } if (input.Length > 100) { return TextResult.Create(\"Error: Input too long (max 100 characters)\"); } // Simulate operation that might fail if (input.ToLower() == \"error\") { throw new InvalidOperationException(\"Simulated error\"); } await Task.Delay(100); // Simulate work return TextResult.Create($\"Operation completed successfully for: {input}\"); } catch (ArgumentException ex) { _logger.LogWarning(ex, \"Invalid argument provided: {Input}\", input); return TextResult.Create($\"Error: Invalid argument - {ex.Message}\"); } catch (Exception ex) { _logger.LogError(ex, \"Unexpected error in SafeOperation with input: {Input}\", input); return TextResult.Create(\"Error: An unexpected error occurred\"); } } } Performance Monitoring [CommandModule(\"Performance\")] public class PerformanceCommands : ICommandBase { private readonly ILogger<PerformanceCommands> _logger; public PerformanceCommands(ILogger<PerformanceCommands> logger) { _logger = logger; } [Command(\"benchmark\", CommandType.Json, \"benchmark <iterations>\", \"Runs a simple benchmark\")] public async Task<ICommandResult> RunBenchmark(int iterations = 1000) { if (iterations < 1 || iterations > 1000000) { return TextResult.Create(\"Error: Iterations must be between 1 and 1,000,000\"); } var stopwatch = System.Diagnostics.Stopwatch.StartNew(); // Simple CPU-bound operation var sum = 0L; for (int i = 0; i < iterations; i++) { sum += i * i; if (i % 10000 == 0) { await Task.Yield(); // Allow other tasks to run } } stopwatch.Stop(); var result = new { Iterations = iterations, ElapsedMilliseconds = stopwatch.ElapsedMilliseconds, IterationsPerSecond = iterations / (stopwatch.ElapsedMilliseconds / 1000.0), Result = sum }; _logger.LogInformation(\"Benchmark completed: {Iterations} iterations in {ElapsedMs}ms\", iterations, stopwatch.ElapsedMilliseconds); return JsonResult.Create(result); } } Summary This examples guide covers: Basic Setup: How to configure Jiro.Commands in an ASP.NET Core application Command Creation: From simple text responses to complex async operations Plugin Development: Complete plugin architecture with services and controllers Type Handling: Working with different parameter types and validation Real-World Scenarios: Database operations, system monitoring, and error handling Best Practices: Error handling, logging, and performance considerations Each example is self-contained and demonstrates specific features of the Jiro.Commands framework. You can use these as starting points for your own command modules and plugins. For more detailed information, see: Command Creation Pipeline Compiled Lambdas API Reference"
  },
  "docs/index.html": {
    "href": "docs/index.html",
    "title": "Jiro.Libs Documentation | Jiro.Libs Documentation",
    "keywords": "Jiro.Libs Documentation Welcome to the Jiro.Libs documentation! This library provides the foundational components for building command-based applications and plugins. Getting Started Jiro.Libs is a powerful library that enables you to create modular, command-driven applications with plugin support. Features Command System: Build applications around a command-based architecture Plugin Framework: Create and load plugins dynamically Type Safety: Strongly-typed command parameters and responses Dependency Injection: Full support for .NET dependency injection Result Types: Rich result types for different response formats Quick Start To get started with Jiro.Libs, install the NuGet package: dotnet add package Jiro.Commands Documentation Sections API Reference - Complete API documentation Examples - Code examples and tutorials Support For issues and feature requests, please visit our GitHub repository."
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to Jiro | Jiro.Libs Documentation",
    "keywords": "Welcome to Jiro Jiro is a comprehensive application framework designed for building modern, scalable applications with powerful command handling, conversation management, and extensible architecture. 🚀 Quick Start Get started with Jiro in minutes: Documentation - Learn about Jiro's features and architecture API Reference - Explore the complete API documentation User Guide - Step-by-step implementation guide ✨ Key Features 🎯 Command System - Extensible command handling framework 💬 Conversation Management - Advanced chat session and message handling 🌤️ Weather Integration - Built-in weather services and data 👤 User Management - Complete authentication and authorization 🗄️ Database Integration - Entity Framework Core with repository pattern 🔌 Extensible Architecture - Plugin-based system for easy extension 📚 Documentation Sections 📖 Documentation Project overview and architecture Getting started guides User documentation Workflow and pipelines Changelog and version history 🔧 API Reference Complete .NET API documentation Class and interface references Method documentation with examples Generated from source code 🏗️ Architecture Overview Jiro.Commands provides a layered architecture with clear separation of concerns: Jiro.Commands - Core command processing library with attributes, controllers, and type parsers Jiro.Commands.Tests - Comprehensive test suite ensuring reliability 🤝 Contributing We welcome contributions! Please see our documentation for guidelines on how to contribute to the Jiro project. Ready to dive in? Start with Documentation or explore the API Reference."
  }
}